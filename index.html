<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyGO!!!!! Roguelike TCG - MVP Stage 1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'human-base': '#9F563A',
                        'human-dark': '#79432C',
                        'human-text': '#F3EAD3',
                        'yin-base': '#293047',
                        'yin-dark': '#1A2033',
                        'yin-text': '#D0D8E8',
                        'yang-base': '#FCFAF2',
                        'yang-dark': '#E0D8C0',
                        'yang-text': '#5D4037',
                        'legendary-ring': '#DAA520'
                    },
                    animation: {
                        'damage': 'damage 1.5s ease-out forwards',
                        'heal': 'heal 1.5s ease-out forwards',
                        'glow': 'glow 2s ease-in-out infinite alternate',
                        'shake': 'shake 0.5s ease-in-out',
                        'card-draw': 'cardDraw 0.8s ease-out forwards'
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; }
        
        @keyframes damage {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #EF4444; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(0.8); opacity: 0; }
        }
        
        @keyframes heal {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #10B981; }
            50% { transform: translateY(-20px) scale(1.1); opacity: 1; }
            100% { transform: translateY(-40px) scale(0.9); opacity: 0; }
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(218, 165, 32, 0.3); }
            to { box-shadow: 0 0 20px rgba(218, 165, 32, 0.7); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes cardDraw {
            0% { transform: translateY(100px) scale(0.5); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        .card-hover {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-hover:hover {
            transform: translateY(-8px) scale(1.05);
            z-index: 20;
        }
        
        .drop-zone {
            transition: all 0.3s ease;
            border: 2px dashed transparent;
        }
        .drop-zone.drag-over {
            border-color: #10B981;
            background-color: rgba(16, 185, 129, 0.1);
            transform: scale(1.02);
        }
        
        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 1.8rem;
            z-index: 1000;
            pointer-events: none;
        }
        
        .pulse-glow {
            animation: pulse 2s infinite;
        }
        
        .card-zone-occupied {
            border-color: #10B981;
            border-style: solid;
        }
        
        .hp-bar-transition {
            transition: width 1s ease-out;
        }
        
        .turn-phase-indicator {
            background: linear-gradient(45deg, #3B82F6, #1D4ED8);
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen">

    <!-- éŠæˆ²æ¨™é¡Œèˆ‡ç‹€æ…‹ -->
    <header class="bg-slate-800 p-4 shadow-lg">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center gap-4">
                <h1 class="text-2xl font-bold bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent">
                    ğŸ¸ MyGO!!!!! Roguelike TCG
                </h1>
                <div class="text-sm text-gray-400">MVP Stage 1 - æ ¸å¿ƒæˆ°é¬¥å¾ªç’°</div>
            </div>
            
            <div class="flex items-center gap-4">
                <!-- å›åˆè¨ˆæ•¸å™¨ -->
                <div class="text-center">
                    <div class="text-xs text-gray-400">å›åˆ</div>
                    <div id="turn-counter" class="text-xl font-bold text-yellow-400">1</div>
                </div>
                
                <!-- ç‰Œåº«è¨ˆæ•¸ -->
                <div class="text-center">
                    <div class="text-xs text-gray-400">ç‰Œåº«</div>
                    <div id="deck-count" class="text-lg font-bold text-blue-400">15</div>
                </div>
                
                <!-- æ£„ç‰Œå †è¨ˆæ•¸ -->
                <div class="text-center">
                    <div class="text-xs text-gray-400">æ£„ç‰Œ</div>
                    <div id="discard-count" class="text-lg font-bold text-purple-400">0</div>
                </div>
                
                <button id="reset-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors">
                    ğŸ”„ é‡ç½®
                </button>
            </div>
        </div>
    </header>

    <!-- ä¸»éŠæˆ²å€åŸŸ -->
    <main class="container mx-auto p-4">
        
        <!-- éŠæˆ²ç‹€æ…‹èˆ‡éšæ®µæŒ‡ç¤ºå™¨ -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            
            <!-- ç©å®¶ç‹€æ…‹ -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-green-400 flex items-center gap-2">
                    ğŸ›¡ï¸ ç©å®¶ç‹€æ…‹
                    <div id="player-status-indicator" class="w-3 h-3 rounded-full bg-green-500 pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>ç”Ÿå‘½å€¼</span>
                        <span id="player-hp" class="font-bold text-green-400">100/100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="player-hp-bar" class="bg-gradient-to-r from-green-500 to-green-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <!-- ç©å®¶buffé¡¯ç¤º -->
                    <div id="player-buffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>

            <!-- éšæ®µæŒ‡ç¤ºå™¨ -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-center">ğŸ¯ éŠæˆ²éšæ®µ</h2>
                <div id="game-phase" class="turn-phase-indicator text-center py-3 px-4 rounded-lg font-bold text-white">
                    æŠ½ç‰Œéšæ®µ
                </div>
                
                <!-- éšæ®µèªªæ˜ -->
                <div id="phase-description" class="text-center text-sm text-gray-400 mt-2">
                    æº–å‚™é–‹å§‹æ–°å›åˆ...
                </div>
            </div>

            <!-- æŠ•æ‰‹ç‹€æ…‹ -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-red-400 flex items-center gap-2">
                    âš”ï¸ æŠ•æ‰‹ç‹€æ…‹
                    <div id="pitcher-status-indicator" class="w-3 h-3 rounded-full bg-red-500 pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>ç”Ÿå‘½å€¼</span>
                        <span id="pitcher-hp" class="font-bold text-red-400">150/150</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="pitcher-hp-bar" class="bg-gradient-to-r from-red-500 to-red-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <div class="flex justify-between text-sm">
                        <span>æ”»æ“ŠåŠ›</span>
                        <span id="pitcher-attack" class="font-bold text-orange-400">30</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>å±¬æ€§</span>
                        <span id="pitcher-attribute" class="font-bold text-purple-400">å¤©</span>
                    </div>
                    
                    <!-- æŠ•æ‰‹debuffé¡¯ç¤º -->
                    <div id="pitcher-debuffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>
        </div>

        <!-- æˆ°é¬¥å€åŸŸ -->
        <div class="bg-slate-800 p-6 rounded-xl mb-6">
            <h2 class="text-xl font-bold mb-6 text-center">âš”ï¸ æˆ°é¬¥å€åŸŸ</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <!-- æ‰“æ“Šå€ -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-red-300">ğŸ—¡ï¸ æ‰“æ“Šå€</h3>
                    <div id="strike-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="strike_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">ğŸ—¡ï¸</div>
                            <div class="text-sm">æ‹–æ‹½æ‰“è€…å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
                
                <!-- è¼”åŠ©å€ -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-blue-300">ğŸ›¡ï¸ è¼”åŠ©å€</h3>
                    <div id="support-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="support_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">ğŸ›¡ï¸</div>
                            <div class="text-sm">æ‹–æ‹½è¼”åŠ©å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
                
                <!-- æ³•è¡“å€ -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-purple-300">âœ¨ æ³•è¡“å€</h3>
                    <div id="spell-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="spell_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">âœ¨</div>
                            <div class="text-sm">æ‹–æ‹½æ³•è¡“å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æˆ°é¬¥æŒ‰éˆ•å€åŸŸ -->
            <div class="flex justify-center gap-4">
                <button id="attack-btn" class="px-8 py-4 bg-red-600 hover:bg-red-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    âš”ï¸ æ”»æ“Šï¼
                </button>
                <button id="end-turn-btn" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    ğŸ”„ çµæŸå›åˆ
                </button>
            </div>
        </div>

        <!-- æ‰‹ç‰Œå€åŸŸ -->
        <div class="bg-slate-800 p-4 rounded-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold">ğŸ´ æ‰‹ç‰Œ</h2>
                <div class="text-sm text-gray-400">
                    <span id="hand-count">0</span>/7 å¼µ
                </div>
            </div>
            <div id="hand-cards" class="flex gap-3 overflow-x-auto pb-2 min-h-[140px]">
                <!-- æ‰‹ç‰Œå°‡åœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </div>

        <!-- éŠæˆ²æ—¥èªŒ -->
        <div class="bg-slate-800 p-4 rounded-xl mt-6">
            <h2 class="text-lg font-bold mb-3 text-purple-400">ğŸ“œ æˆ°é¬¥æ—¥èªŒ</h2>
            <div id="game-log" class="h-32 overflow-y-auto space-y-1 text-sm bg-slate-900 p-3 rounded">
                <div class="text-green-400">ğŸš€ éŠæˆ²é–‹å§‹ï¼æ­¡è¿ä¾†åˆ° MyGO!!!!! Roguelike TCG</div>
            </div>
        </div>
    </main>

    <!-- JavaScript æ ¸å¿ƒæˆ°é¬¥ç³»çµ± -->
    <script>
        // ===== ğŸ® éŠæˆ²ç‹€æ…‹ç®¡ç† =====
        class GameState {
            constructor() {
                this.player = {
                    current_hp: 100,
                    max_hp: 100,
                    deck: [],
                    hand: [],
                    discard_pile: [],
                    strike_zone: null,
                    support_zone: null,
                    spell_zone: null,
                    active_buffs: []
                };
                
                this.pitcher = {
                    current_hp: 150,
                    max_hp: 150,
                    base_attack: 30,
                    current_attack: 30,
                    attribute: 'heaven',
                    active_debuffs: []
                };
                
                this.gamePhase = 'DRAW_PHASE';
                this.turnCount = 1;
                this.turnBuffs = [];
            }
        }

        // ===== ğŸƒ å¡ç‰Œæ•¸æ“šåº« =====
        const CARD_DATABASE = {
            president: {
                id: 'president',
                name: 'ç¸½çµ±',
                type: 'batter',
                attribute: 'human',
                rarity: 'common',
                stats: { attack: 15, crit: 35, hp_bonus: 10 },
                description: 'æ‰“æ“Šï¼šç‰Œçµ„ä¸­æ¯æœ‰ä¸€å¼µäººå±¬æ€§å¡ï¼Œæ”»æ“ŠåŠ›+1',
                effects: {
                    on_strike: function(gameState) {
                        const humanCards = gameState.player.hand.filter(c => c.attribute === 'human').length;
                        this.tempAttackBonus = humanCards;
                        return {
                            success: true,
                            description: `äººå±¬æ€§å¡æ•¸é‡ï¼š${humanCards}ï¼Œæ”»æ“ŠåŠ›+${humanCards}`
                        };
                    }
                }
            },
            
            kindness: {
                id: 'kindness',
                name: 'æ…ˆæ„›',
                type: 'batter',
                attribute: 'human',
                rarity: 'common',
                stats: { attack: 8, crit: 70, hp_bonus: 12 },
                description: 'è¼”åŠ©ï¼šäººå±¬æ€§æ‰“è€…å¡æœ¬å›åˆæ”»æ“ŠåŠ›+10',
                effects: {
                    on_support: function(gameState) {
                        gameState.turnBuffs.push({
                            type: 'human_batter_boost',
                            value: 10,
                            source: this.name
                        });
                        return {
                            success: true,
                            description: 'äººå±¬æ€§æ‰“è€…å¡æœ¬å›åˆæ”»æ“ŠåŠ›+10'
                        };
                    }
                }
            },
            
            hero: {
                id: 'hero',
                name: 'è‹±é›„',
                type: 'batter',
                attribute: 'human',
                rarity: 'common',
                stats: { attack: 25, crit: 50, hp_bonus: 10 },
                description: 'åŸºç¤æ‰“è€…å¡ï¼Œç„¡ç‰¹æ®Šæ•ˆæœ',
                effects: {}
            },
            
            shadow_devour: {
                id: 'shadow_devour',
                name: 'æš—å½±åå™¬',
                type: 'batter',
                attribute: 'yin',
                rarity: 'common',
                stats: { attack: 20, crit: 35, hp_bonus: 10 },
                description: 'æ‰“æ“Šï¼šè‹¥æœ¬å›åˆæ²’æœ‰å…¶ä»–é™°å±¬å¡ï¼Œæ”»æ“ŠåŠ›+10',
                effects: {
                    on_strike: function(gameState) {
                        // ç°¡åŒ–å¯¦ç¾ï¼šç›´æ¥çµ¦äºˆåŠ æˆ
                        this.tempAttackBonus = 10;
                        return {
                            success: true,
                            description: 'æœ¬å›åˆæœªæ‰“å‡ºå…¶ä»–é™°å±¬å¡ï¼Œæ”»æ“ŠåŠ›+10'
                        };
                    }
                }
            },
            
            yinyang_harmony: {
                id: 'yinyang_harmony',
                name: 'é™°é™½èª¿å’Œ',
                type: 'batter',
                attribute: 'yang',
                rarity: 'rare',
                stats: { attack: 20, crit: 25, hp_bonus: 0 },
                description: 'æ‰“æ“Šï¼šè‹¥è¼”åŠ©æ ¼ç‚ºé™°å±¬æ€§ï¼Œæ”»æ“ŠåŠ›ç¿»å€',
                effects: {
                    on_strike: function(gameState) {
                        const supportCard = gameState.player.support_zone;
                        if (supportCard && supportCard.attribute === 'yin') {
                            this.tempAttackBonus = this.stats.attack;
                            return {
                                success: true,
                                description: 'è¼”åŠ©æ ¼ç‚ºé™°å±¬æ€§ï¼Œæ”»æ“ŠåŠ›ç¿»å€ï¼'
                            };
                        }
                        return { success: false, reason: 'è¼”åŠ©æ ¼ä¸æ˜¯é™°å±¬æ€§' };
                    }
                }
            }
        };

        // åˆå§‹ç‰Œçµ„é…ç½®
        const INITIAL_DECK = [
            'president', 'president', 'kindness', 'kindness', 
            'hero', 'hero', 'hero', 'shadow_devour', 'yinyang_harmony',
            'president', 'kindness', 'hero', 'shadow_devour', 'yinyang_harmony', 'hero'
        ];

        // ===== ğŸ¨ UI å·¥å…·å‡½æ•¸ =====
        class UIManager {
            static generateCardClasses(attribute, rarity) {
                const baseClasses = 'w-28 h-36 rounded-xl p-3 text-xs cursor-pointer card-hover flex flex-col justify-between';
                
                const attributeColors = {
                    human: { base: 'human-base', dark: 'human-dark', text: 'human-text' },
                    yin: { base: 'yin-base', dark: 'yin-dark', text: 'yin-text' },
                    yang: { base: 'yang-base', dark: 'yang-dark', text: 'yang-text' }
                };
                
                const rarityStyles = {
                    common: (colors) => `bg-${colors.base}`,
                    rare: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-lg`,
                    legendary: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-xl ring-2 ring-legendary-ring animate-glow`
                };
                
                const colors = attributeColors[attribute] || attributeColors.human;
                const backgroundStyle = rarityStyles[rarity](colors);
                
                return `${baseClasses} ${backgroundStyle} text-${colors.text}`;
            }

            static renderCard(cardData, index, showDetails = true) {
                const cardClasses = this.generateCardClasses(cardData.attribute, cardData.rarity);
                
                return `
                    <div class="${cardClasses} animate-card-draw" draggable="true" data-card-index="${index}" style="animation-delay: ${index * 0.1}s">
                        <div class="text-center mb-2">
                            <div class="font-bold text-sm mb-1">${cardData.name}</div>
                            <div class="text-[10px] opacity-80 bg-black/20 px-2 py-1 rounded">${cardData.attribute} â€¢ ${cardData.type}</div>
                        </div>
                        
                        ${showDetails ? `
                        <div class="flex-1 text-[10px] leading-tight opacity-90">
                            ${cardData.description}
                        </div>
                        ` : ''}
                        
                        <div class="flex justify-between text-[11px] font-bold mt-2 bg-black/20 p-1 rounded">
                            <span title="æ”»æ“ŠåŠ›">âš”ï¸${cardData.stats.attack}</span>
                            <span title="æš´æ“Šå€¼">ğŸ’${cardData.stats.crit}</span>
                        </div>
                    </div>
                `;
            }

            static showFloatingText(element, text, type = 'damage') {
                const floatingText = document.createElement('div');
                floatingText.className = `floating-text animate-${type}`;
                floatingText.textContent = text;
                
                const rect = element.getBoundingClientRect();
                floatingText.style.left = `${rect.left + rect.width / 2 - 20}px`;
                floatingText.style.top = `${rect.top}px`;
                
                document.body.appendChild(floatingText);
                
                setTimeout(() => {
                    if (document.body.contains(floatingText)) {
                        document.body.removeChild(floatingText);
                    }
                }, 1500);
            }

            static addLog(message, type = 'info') {
                const logContainer = document.getElementById('game-log');
                const logEntry = document.createElement('div');
                
                const colors = {
                    info: 'text-gray-300',
                    success: 'text-green-400',
                    damage: 'text-red-400',
                    heal: 'text-green-400',
                    system: 'text-blue-400',
                    warning: 'text-yellow-400'
                };
                
                logEntry.className = colors[type] || colors.info;
                logEntry.innerHTML = `<span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            static updatePhaseDisplay(phase) {
                const phaseElement = document.getElementById('game-phase');
                const descriptionElement = document.getElementById('phase-description');
                
                const phaseData = {
                    'DRAW_PHASE': {
                        name: 'æŠ½ç‰Œéšæ®µ',
                        description: 'è£œå……æ‰‹ç‰Œè‡³7å¼µ',
                        color: 'bg-blue-600'
                    },
                    'PLAY_PHASE': {
                        name: 'å‡ºç‰Œéšæ®µ', 
                        description: 'æ‹–æ‹½å¡ç‰Œåˆ°æˆ°é¬¥å€åŸŸ',
                        color: 'bg-green-600'
                    },
                    'COMBAT_PHASE': {
                        name: 'æˆ°é¬¥éšæ®µ',
                        description: 'è¨ˆç®—å‚·å®³ä¸¦åŸ·è¡Œæ”»æ“Š',
                        color: 'bg-red-600'
                    }
                };
                
                const data = phaseData[phase];
                phaseElement.textContent = data.name;
                phaseElement.className = `turn-phase-indicator text-center py-3 px-4 rounded-lg font-bold text-white ${data.color}`;
                descriptionElement.textContent = data.description;
            }
        }

        // ===== âš”ï¸ æˆ°é¬¥ç³»çµ± =====
        class CombatSystem {
            static calculateDamage(gameState) {
                let totalAttack = 0;
                let totalCrit = 0;
                const effects = [];
                
                // åŸºç¤æ•¸å€¼è¨ˆç®—
                const strikeCard = gameState.player.strike_zone;
                const supportCard = gameState.player.support_zone;
                
                if (strikeCard) {
                    totalAttack += strikeCard.stats.attack;
                    totalCrit += strikeCard.stats.crit;
                    
                    // è§¸ç™¼æ‰“æ“Šæ•ˆæœ
                    if (strikeCard.effects.on_strike) {
                        const result = strikeCard.effects.on_strike.call(strikeCard, gameState);
                        if (result.success) {
                            effects.push(result.description);
                            if (strikeCard.tempAttackBonus) {
                                totalAttack += strikeCard.tempAttackBonus;
                            }
                        }
                    }
                }
                
                if (supportCard) {
                    totalAttack += supportCard.stats.attack;
                    totalCrit += supportCard.stats.crit;
                    
                    // è§¸ç™¼è¼”åŠ©æ•ˆæœ
                    if (supportCard.effects.on_support) {
                        const result = supportCard.effects.on_support.call(supportCard, gameState);
                        if (result.success) {
                            effects.push(result.description);
                        }
                    }
                }
                
                // æ‡‰ç”¨å›åˆBuff
                gameState.turnBuffs.forEach(buff => {
                    if (buff.type === 'human_batter_boost' && strikeCard && strikeCard.attribute === 'human') {
                        totalAttack += buff.value;
                        effects.push(`${buff.source}ï¼šäººå±¬æ€§æ‰“è€…+${buff.value}æ”»æ“ŠåŠ›`);
                    }
                });
                
                // è¨ˆç®—æœ€çµ‚å‚·å®³
                let finalDamage = totalAttack * (1 + totalCrit / 100);
                
                // å±¬æ€§å…‹åˆ¶
                const playerAttr = strikeCard ? strikeCard.attribute : 'human';
                if (this.isStrongAgainst(playerAttr, gameState.pitcher.attribute)) {
                    finalDamage *= 1.2;
                    effects.push(`å±¬æ€§å…‹åˆ¶ï¼š${playerAttr} å…‹åˆ¶ ${gameState.pitcher.attribute}ï¼Œå‚·å®³+20%`);
                }
                
                return {
                    finalDamage: Math.round(finalDamage),
                    breakdown: {
                        baseAttack: totalAttack,
                        baseCrit: totalCrit,
                        effects: effects
                    }
                };
            }
            
            static isStrongAgainst(playerAttr, enemyAttr) {
                const advantages = {
                    'human': ['yin'],
                    'yin': ['yang'], 
                    'yang': ['heaven'],
                    'heaven': ['earth'],
                    'earth': ['human']
                };
                return advantages[playerAttr]?.includes(enemyAttr) || false;
            }
            
            static calculatePitcherDamage(gameState) {
                let damage = gameState.pitcher.current_attack;
                
                // æ‡‰ç”¨å±¬æ€§å…‹åˆ¶ï¼ˆç©å®¶è¢«å…‹åˆ¶æ™‚å‚·å®³æ¸›å°‘ï¼‰
                const playerAttr = gameState.player.strike_zone ? gameState.player.strike_zone.attribute : 'human';
                if (this.isStrongAgainst(gameState.pitcher.attribute, playerAttr)) {
                    damage *= 0.8;
                }
                
                return Math.round(damage);
            }
        }

        // ===== ğŸ¯ å›åˆç³»çµ± =====
        class TurnSystem {
            static async processTurn(gameState) {
                UIManager.addLog(`ğŸ”„ ç¬¬ ${gameState.turnCount} å›åˆé–‹å§‹`, 'system');
                
                // 1. å›åˆé–‹å§‹éšæ®µ
                gameState.gamePhase = 'DRAW_PHASE';
                UIManager.updatePhaseDisplay(gameState.gamePhase);
                
                // 2. æŠ½ç‰Œéšæ®µ
                await this.drawPhase(gameState);
                
                // 3. åˆ‡æ›åˆ°å‡ºç‰Œéšæ®µ
                gameState.gamePhase = 'PLAY_PHASE';
                UIManager.updatePhaseDisplay(gameState.gamePhase);
                
                GameController.updateAllDisplays();
            }
            
            static async drawPhase(gameState) {
                const handSizeLimit = 7;
                const drawCount = handSizeLimit - gameState.player.hand.length;
                
                if (drawCount > 0) {
                    UIManager.addLog(`ğŸ´ æŠ½ç‰Œéšæ®µï¼šéœ€è¦æŠ½ ${drawCount} å¼µç‰Œ`, 'system');
                    
                    for (let i = 0; i < drawCount; i++) {
                        if (!this.drawSingleCard(gameState)) {
                            UIManager.addLog('âš ï¸ ç„¡æ³•ç¹¼çºŒæŠ½ç‰Œï¼Œç‰Œåº«å·²ç©º', 'warning');
                            break;
                        }
                        // å»¶é²ä»¥å±•ç¤ºæŠ½ç‰Œå‹•ç•«
                        await new Promise(resolve => setTimeout(resolve, 200));
                        GameController.updateHandDisplay();
                    }
                }
            }
            
            static drawSingleCard(gameState) {
                // å¦‚æœç‰Œåº«ç‚ºç©ºï¼Œé‡æ–°æ´—ç‰Œ
                if (gameState.player.deck.length === 0) {
                    if (gameState.player.discard_pile.length === 0) {
                        return false;
                    }
                    
                    UIManager.addLog('ğŸ”€ ç‰Œåº«ç‚ºç©ºï¼Œé‡æ–°æ´—ç‰Œ...', 'system');
                    gameState.player.deck = [...gameState.player.discard_pile];
                    gameState.player.discard_pile = [];
                    this.shuffleDeck(gameState.player.deck);
                }
                
                if (gameState.player.deck.length > 0) {
                    const cardId = gameState.player.deck.pop();
                    const fullCard = { ...CARD_DATABASE[cardId] };
                    gameState.player.hand.push(fullCard);
                    
                    UIManager.addLog(`ğŸ´ æŠ½åˆ°ï¼š${fullCard.name}`, 'success');
                    return true;
                }
                
                return false;
            }
            
            static shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }
            
            static async endTurn(gameState) {
                UIManager.addLog('ğŸŒ™ å›åˆçµæŸéšæ®µé–‹å§‹', 'system');
                gameState.gamePhase = 'END_TURN';
                UIManager.updatePhaseDisplay({ 'END_TURN': { name: 'å›åˆçµæŸ', description: 'æ¸…ç†æ•ˆæœä¸¦æº–å‚™ä¸‹å›åˆ', color: 'bg-purple-600' } }['END_TURN']);
                
                // 1. ç§»å‹•å ´ä¸Šå¡ç‰Œåˆ°æ£„ç‰Œå †
                this.moveCardsToDiscard(gameState);
                
                // 2. æŠ•æ‰‹ç–²å‹
                const oldAttack = gameState.pitcher.current_attack;
                gameState.pitcher.current_attack = Math.round(gameState.pitcher.current_attack * 0.95);
                UIManager.addLog(`ğŸ˜´ æŠ•æ‰‹ç–²å‹ï¼šæ”»æ“ŠåŠ› ${oldAttack} â†’ ${gameState.pitcher.current_attack}`, 'system');
                
                // 3. æ¸…ç†è‡¨æ™‚æ•ˆæœ
                this.cleanupTurnEffects(gameState);
                
                // 4. å¢åŠ å›åˆè¨ˆæ•¸
                gameState.turnCount++;
                
                // 5. é–‹å§‹æ–°å›åˆ
                setTimeout(() => {
                    this.processTurn(gameState);
                }, 1500);
                
                GameController.updateAllDisplays();
            }
            
            static moveCardsToDiscard(gameState) {
                const zones = ['strike_zone', 'support_zone', 'spell_zone'];
                let movedCards = 0;
                
                zones.forEach(zone => {
                    if (gameState.player[zone]) {
                        const card = gameState.player[zone];
                        gameState.player.discard_pile.push(card);
                        gameState.player[zone] = null;
                        UIManager.addLog(`ğŸ—‚ï¸ ${card.name} ç§»å…¥æ£„ç‰Œå †`, 'system');
                        movedCards++;
                    }
                });
                
                if (movedCards === 0) {
                    UIManager.addLog('ğŸ“ æ²’æœ‰å¡ç‰Œéœ€è¦ç§»å…¥æ£„ç‰Œå †', 'system');
                }
            }
            
            static cleanupTurnEffects(gameState) {
                // æ¸…ç†å›åˆBuff
                gameState.turnBuffs = [];
                
                // æ¸…ç†å¡ç‰Œè‡¨æ™‚æ•ˆæœ
                gameState.player.hand.forEach(card => {
                    delete card.tempAttackBonus;
                });
            }
        }

        // ===== ğŸ® éŠæˆ²æ§åˆ¶å™¨ =====
        class GameController {
            static gameState = new GameState();
            
            static initialize() {
                // åˆå§‹åŒ–ç‰Œçµ„
                this.gameState.player.deck = [...INITIAL_DECK];
                TurnSystem.shuffleDeck(this.gameState.player.deck);
                
                // è¨­ç½®äº‹ä»¶ç›£è½
                this.setupEventListeners();
                
                // é–‹å§‹ç¬¬ä¸€å›åˆ
                TurnSystem.processTurn(this.gameState);
                
                UIManager.addLog('ğŸš€ éŠæˆ²åˆå§‹åŒ–å®Œæˆ', 'system');
            }
            
            static setupEventListeners() {
                // æ”»æ“ŠæŒ‰éˆ•
                document.getElementById('attack-btn').addEventListener('click', () => {
                    this.executeAttack();
                });
                
                // çµæŸå›åˆæŒ‰éˆ•
                document.getElementById('end-turn-btn').addEventListener('click', () => {
                    TurnSystem.endTurn(this.gameState);
                });
                
                // é‡ç½®æŒ‰éˆ•
                document.getElementById('reset-btn').addEventListener('click', () => {
                    if (confirm('ç¢ºå®šè¦é‡ç½®éŠæˆ²å—ï¼Ÿ')) {
                        this.resetGame();
                    }
                });
                
                // è¨­ç½®æ‹–æ”¾
                this.setupDragAndDrop();
            }
            
            static setupDragAndDrop() {
                const zones = ['strike-zone', 'support-zone', 'spell-zone'];
                
                zones.forEach(zoneId => {
                    const zone = document.getElementById(zoneId);
                    
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        zone.classList.add('drag-over');
                    });

                    zone.addEventListener('dragleave', () => {
                        zone.classList.remove('drag-over');
                    });

                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.classList.remove('drag-over');
                        
                        const cardIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const targetZone = zone.dataset.zone;
                        
                        this.playCard(cardIndex, targetZone);
                    });
                });
            }
            
            static playCard(cardIndex, targetZone) {
                const card = this.gameState.player.hand[cardIndex];
                if (!card) {
                    UIManager.addLog('âŒ ç„¡æ•ˆçš„å¡ç‰Œç´¢å¼•', 'damage');
                    return;
                }
                
                // æª¢æŸ¥éŠæˆ²éšæ®µ
                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    UIManager.addLog('âŒ ä¸åœ¨å‡ºç‰Œéšæ®µï¼', 'damage');
                    return;
                }
                
                // æª¢æŸ¥å€åŸŸæ˜¯å¦å·²æœ‰å¡ç‰Œ
                if (this.gameState.player[targetZone]) {
                    UIManager.addLog('âŒ è©²å€åŸŸå·²æœ‰å¡ç‰Œï¼', 'damage');
                    return;
                }
                
                // æª¢æŸ¥å¡ç‰Œé¡å‹æ˜¯å¦åŒ¹é…
                const validPlacements = {
                    'strike_zone': ['batter'],
                    'support_zone': ['batter', 'support'],
                    'spell_zone': ['spell']                };
                
                if (!validPlacements[targetZone].includes(card.type)) {
                    UIManager.addLog('âŒ å¡ç‰Œé¡å‹ä¸åŒ¹é…ï¼', 'damage');
                    return;
                }
                
                // æ”¾ç½®å¡ç‰Œ
                this.gameState.player[targetZone] = card;
                this.gameState.player.hand.splice(cardIndex, 1);
                
                const zoneNames = {
                    'strike_zone': 'æ‰“æ“Šå€',
                    'support_zone': 'è¼”åŠ©å€', 
                    'spell_zone': 'æ³•è¡“å€'
                };
                
                UIManager.addLog(`ğŸ´ ${card.name} æ”¾ç½®åˆ°${zoneNames[targetZone]}`, 'success');
                this.updateAllDisplays();
            }
            
            static executeAttack() {
                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    UIManager.addLog('âŒ ä¸åœ¨å‡ºç‰Œéšæ®µï¼', 'damage');
                    return;
                }
                
                if (!this.gameState.player.strike_zone) {
                    UIManager.addLog('âŒ è«‹å…ˆæ”¾ç½®æ‰“æ“Šå¡ç‰Œï¼', 'damage');
                    return;
                }
                
                // åˆ‡æ›åˆ°æˆ°é¬¥éšæ®µ
                this.gameState.gamePhase = 'COMBAT_PHASE';
                UIManager.updatePhaseDisplay(this.gameState.gamePhase);
                
                // åŸ·è¡Œæˆ°é¬¥
                this.executeCombat();
            }
            
            static executeCombat() {
                UIManager.addLog('âš”ï¸ æˆ°é¬¥é–‹å§‹ï¼', 'system');
                
                // è¨ˆç®—ç©å®¶å‚·å®³
                const damageResult = CombatSystem.calculateDamage(this.gameState);
                
                // é¡¯ç¤ºæ•ˆæœèªªæ˜
                damageResult.breakdown.effects.forEach(effect => {
                    UIManager.addLog(`âœ¨ ${effect}`, 'success');
                });
                
                // å°æŠ•æ‰‹é€ æˆå‚·å®³
                this.gameState.pitcher.current_hp -= damageResult.finalDamage;
                this.gameState.pitcher.current_hp = Math.max(0, this.gameState.pitcher.current_hp);
                
                UIManager.addLog(`ğŸ’¥ å°æŠ•æ‰‹é€ æˆ ${damageResult.finalDamage} é»å‚·å®³ï¼`, 'damage');
                UIManager.showFloatingText(document.getElementById('pitcher-hp'), `-${damageResult.finalDamage}`, 'damage');
                
                // éœ‡å‹•æ•ˆæœ
                document.getElementById('pitcher-hp-bar').classList.add('animate-shake');
                setTimeout(() => {
                    document.getElementById('pitcher-hp-bar').classList.remove('animate-shake');
                }, 500);
                
                // æª¢æŸ¥æŠ•æ‰‹æ˜¯å¦è¢«æ“Šæ•—
                if (this.gameState.pitcher.current_hp <= 0) {
                    UIManager.addLog('ğŸ† å‹åˆ©ï¼æŠ•æ‰‹è¢«æ“Šæ•—äº†ï¼', 'success');
                    setTimeout(() => {
                        alert('ğŸ‰ æ­å–œå‹åˆ©ï¼\n\nåœ¨å®Œæ•´ç‰ˆæœ¬ä¸­ï¼Œé€™è£¡å°‡é€²å…¥çå‹µé¸æ“‡éšæ®µã€‚');
                    }, 1000);
                    this.updateAllDisplays();
                    return;
                }
                
                // æŠ•æ‰‹åæ“Š
                setTimeout(() => {
                    this.pitcherAttack();
                }, 1000);
                
                this.updateAllDisplays();
            }
            
            static pitcherAttack() {
                const pitcherDamage = CombatSystem.calculatePitcherDamage(this.gameState);
                
                this.gameState.player.current_hp -= pitcherDamage;
                this.gameState.player.current_hp = Math.max(0, this.gameState.player.current_hp);
                
                UIManager.addLog(`ğŸ’¢ æŠ•æ‰‹åæ“Šï¼å—åˆ° ${pitcherDamage} é»å‚·å®³ï¼`, 'damage');
                UIManager.showFloatingText(document.getElementById('player-hp'), `-${pitcherDamage}`, 'damage');
                
                // éœ‡å‹•æ•ˆæœ
                document.getElementById('player-hp-bar').classList.add('animate-shake');
                setTimeout(() => {
                    document.getElementById('player-hp-bar').classList.remove('animate-shake');
                }, 500);
                
                // æª¢æŸ¥ç©å®¶æ˜¯å¦è¢«æ“Šæ•—
                if (this.gameState.player.current_hp <= 0) {
                    UIManager.addLog('ğŸ’€ å¤±æ•—ï¼ä½ è¢«æ“Šæ•—äº†ï¼', 'damage');
                    setTimeout(() => {
                        alert('ğŸ’€ éŠæˆ²çµæŸï¼\n\né»æ“Šé‡ç½®é–‹å§‹æ–°éŠæˆ²ã€‚');
                    }, 1000);
                    this.updateAllDisplays();
                    return;
                }
                
                this.updateAllDisplays();
                
                // è‡ªå‹•çµæŸå›åˆ
                setTimeout(() => {
                    TurnSystem.endTurn(this.gameState);
                }, 1500);
            }
            
            static resetGame() {
                this.gameState = new GameState();
                document.getElementById('game-log').innerHTML = '';
                this.initialize();
                UIManager.addLog('ğŸ”„ éŠæˆ²å·²é‡ç½®', 'system');
            }
            
            static updateAllDisplays() {
                this.updateHandDisplay();
                this.updateBattleZones();
                this.updateStatusDisplay();
                this.updateCounters();
            }
            
            static updateHandDisplay() {
                const handContainer = document.getElementById('hand-cards');
                const handCountElement = document.getElementById('hand-count');
                
                handContainer.innerHTML = this.gameState.player.hand
                    .map((card, index) => UIManager.renderCard(card, index))
                    .join('');
                
                handCountElement.textContent = this.gameState.player.hand.length;
                
                // é‡æ–°ç¶å®šæ‹–æ‹½äº‹ä»¶
                this.bindCardDragEvents();
            }
            
            static bindCardDragEvents() {
                const cards = document.querySelectorAll('[data-card-index]');
                cards.forEach(card => {
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', e.target.dataset.cardIndex);
                    });
                });
            }
            
            static updateBattleZones() {
                const zones = ['strike_zone', 'support_zone', 'spell_zone'];
                const zoneNames = { 
                    strike_zone: 'æ‰“æ“Šå€', 
                    support_zone: 'è¼”åŠ©å€', 
                    spell_zone: 'æ³•è¡“å€' 
                };
                const zoneIcons = { 
                    strike_zone: 'ğŸ—¡ï¸', 
                    support_zone: 'ğŸ›¡ï¸', 
                    spell_zone: 'âœ¨' 
                };
                
                zones.forEach(zone => {
                    const zoneElement = document.getElementById(zone.replace('_', '-'));
                    const card = this.gameState.player[zone];
                    
                    if (card) {
                        zoneElement.innerHTML = UIManager.renderCard(card, -1, false);
                        zoneElement.classList.add('card-zone-occupied');
                    } else {
                        zoneElement.innerHTML = `
                            <div class="text-center text-gray-400">
                                <div class="text-3xl mb-2">${zoneIcons[zone]}</div>
                                <div class="text-sm">æ‹–æ‹½${zone === 'strike_zone' ? 'æ‰“è€…' : zone === 'support_zone' ? 'è¼”åŠ©' : 'æ³•è¡“'}å¡åˆ°æ­¤è™•</div>
                            </div>
                        `;
                        zoneElement.classList.remove('card-zone-occupied');
                    }
                });
            }
            
            static updateStatusDisplay() {
                // æ›´æ–°ç©å®¶ç‹€æ…‹
                document.getElementById('player-hp').textContent = 
                    `${this.gameState.player.current_hp}/${this.gameState.player.max_hp}`;
                document.getElementById('player-hp-bar').style.width = 
                    `${(this.gameState.player.current_hp / this.gameState.player.max_hp) * 100}%`;
                
                // æ›´æ–°æŠ•æ‰‹ç‹€æ…‹
                document.getElementById('pitcher-hp').textContent = 
                    `${this.gameState.pitcher.current_hp}/${this.gameState.pitcher.max_hp}`;
                document.getElementById('pitcher-hp-bar').style.width = 
                    `${(this.gameState.pitcher.current_hp / this.gameState.pitcher.max_hp) * 100}%`;
                document.getElementById('pitcher-attack').textContent = this.gameState.pitcher.current_attack;
                document.getElementById('pitcher-attribute').textContent = this.gameState.pitcher.attribute;
            }
            
            static updateCounters() {
                document.getElementById('turn-counter').textContent = this.gameState.turnCount;
                document.getElementById('deck-count').textContent = this.gameState.player.deck.length;
                document.getElementById('discard-count').textContent = this.gameState.player.discard_pile.length;
            }
        }

        // ===== ğŸš€ éŠæˆ²å•Ÿå‹• =====
        document.addEventListener('DOMContentLoaded', () => {
            GameController.initialize();
            
            // æ·»åŠ èª¿è©¦åŠŸèƒ½
            window.gameDebug = {
                state: GameController.gameState,
                addCard: (cardId) => {
                    if (CARD_DATABASE[cardId] && GameController.gameState.player.hand.length < 7) {
                        GameController.gameState.player.hand.push({ ...CARD_DATABASE[cardId] });
                        GameController.updateAllDisplays();
                        UIManager.addLog(`ğŸ”§ èª¿è©¦ï¼šæ·»åŠ äº† ${CARD_DATABASE[cardId].name}`, 'system');
                    }
                },
                damage: (amount) => {
                    GameController.gameState.pitcher.current_hp -= amount;
                    GameController.gameState.pitcher.current_hp = Math.max(0, GameController.gameState.pitcher.current_hp);
                    GameController.updateAllDisplays();
                    UIManager.addLog(`ğŸ”§ èª¿è©¦ï¼šå°æŠ•æ‰‹é€ æˆ ${amount} é»å‚·å®³`, 'system');
                },
                heal: (amount) => {
                    GameController.gameState.player.current_hp += amount;
                    GameController.gameState.player.current_hp = Math.min(GameController.gameState.player.max_hp, GameController.gameState.player.current_hp);
                    GameController.updateAllDisplays();
                    UIManager.addLog(`ğŸ”§ èª¿è©¦ï¼šå›å¾© ${amount} é»ç”Ÿå‘½å€¼`, 'system');
                }
            };
            
            UIManager.addLog('ğŸ® æ­¡è¿ä¾†åˆ° MyGO!!!!! Roguelike TCGï¼', 'success');
            UIManager.addLog('ğŸ’¡ æç¤ºï¼šå°‡å¡ç‰Œæ‹–æ‹½åˆ°æˆ°é¬¥å€åŸŸï¼Œç„¶å¾Œé»æ“Šæ”»æ“Šï¼', 'system');
        });

    </script>
</body>
</html>

        //
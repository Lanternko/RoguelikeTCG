<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyGO!!!!! Roguelike TCG v2 - å®Œæ•´ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'human-base': '#9F563A',
                        'human-dark': '#79432C',
                        'human-text': '#F3EAD3',
                        'yin-base': '#293047',
                        'yin-dark': '#1A2033',
                        'yin-text': '#D0D8E8',
                        'yang-base': '#FCFAF2',
                        'yang-dark': '#E0D8C0',
                        'yang-text': '#5D4037',
                        'heaven-base': '#4A90E2',
                        'heaven-dark': '#357ABD',
                        'heaven-text': '#F0F8FF',
                        'earth-base': '#8B4513',
                        'earth-dark': '#654321',
                        'earth-text': '#F5DEB3',
                        'legendary-ring': '#DAA520'
                    },
                    animation: {
                        'damage': 'damage 1.5s ease-out forwards',
                        'heal': 'heal 1.5s ease-out forwards',
                        'glow': 'glow 2s ease-in-out infinite alternate',
                        'shake': 'shake 0.5s ease-in-out',
                        'card-draw': 'cardDraw 0.8s ease-out forwards',
                        'pulse-glow': 'pulseGlow 2s ease-in-out infinite'
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; }
        
        @keyframes damage {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #EF4444; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(0.8); opacity: 0; }
        }
        
        @keyframes heal {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #10B981; }
            50% { transform: translateY(-20px) scale(1.1); opacity: 1; }
            100% { transform: translateY(-40px) scale(0.9); opacity: 0; }
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(218, 165, 32, 0.3); }
            to { box-shadow: 0 0 20px rgba(218, 165, 32, 0.7); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes cardDraw {
            0% { transform: translateY(100px) scale(0.5); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        @keyframes pulseGlow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .card-hover {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-hover:hover {
            transform: translateY(-8px) scale(1.05);
            z-index: 20;
        }
        
        .drop-zone {
            transition: all 0.3s ease;
            border: 2px dashed transparent;
        }
        .drop-zone.drag-over {
            border-color: #10B981;
            background-color: rgba(16, 185, 129, 0.1);
            transform: scale(1.02);
        }
        
        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 1.8rem;
            z-index: 1000;
            pointer-events: none;
        }
        
        .hp-bar-transition {
            transition: width 1s ease-out;
        }
        
        .card-zone-occupied {
            border-color: #10B981;
            border-style: solid;
        }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen">

    <!-- éŠæˆ²æ¨™é¡Œèˆ‡ç‹€æ…‹ -->
    <header class="bg-slate-800 p-4 shadow-lg">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center gap-4">
                <h1 class="text-2xl font-bold bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent">
                    ğŸ¸ MyGO!!!!! Roguelike TCG v2
                </h1>
                <div class="text-sm text-gray-400">åˆ†å±¤æ¶æ§‹å®Œæ•´ç‰ˆ</div>
            </div>
            
            <div class="flex items-center gap-4">
                <div class="text-center">
                    <div class="text-xs text-gray-400">å›åˆ</div>
                    <div id="turn-counter" class="text-xl font-bold text-yellow-400">1</div>
                </div>
                
                <div class="text-center">
                    <div class="text-xs text-gray-400">ç‰Œåº«</div>
                    <div id="deck-count" class="text-lg font-bold text-blue-400">15</div>
                </div>
                
                <div class="text-center">
                    <div class="text-xs text-gray-400">æ£„ç‰Œ</div>
                    <div id="discard-count" class="text-lg font-bold text-purple-400">0</div>
                </div>
                
                <button id="reset-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors">
                    ğŸ”„ é‡ç½®
                </button>
            </div>
        </div>
    </header>

    <!-- ä¸»éŠæˆ²å€åŸŸ -->
    <main class="container mx-auto p-4">
        
        <!-- éŠæˆ²ç‹€æ…‹èˆ‡éšæ®µæŒ‡ç¤ºå™¨ -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            
            <!-- ç©å®¶ç‹€æ…‹ -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-green-400 flex items-center gap-2">
                    ğŸ›¡ï¸ ç©å®¶ç‹€æ…‹
                    <div id="player-status-indicator" class="w-3 h-3 rounded-full bg-green-500 animate-pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>ç”Ÿå‘½å€¼</span>
                        <span id="player-hp" class="font-bold text-green-400">100/100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="player-hp-bar" class="bg-gradient-to-r from-green-500 to-green-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <div id="player-buffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>

            <!-- éšæ®µæŒ‡ç¤ºå™¨ -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-center">ğŸ¯ éŠæˆ²éšæ®µ</h2>
                <div id="game-phase" class="bg-blue-600 text-center py-3 px-4 rounded-lg font-bold text-white">
                    æŠ½ç‰Œéšæ®µ
                </div>
                
                <div id="phase-description" class="text-center text-sm text-gray-400 mt-2">
                    æº–å‚™é–‹å§‹æ–°å›åˆ...
                </div>
            </div>

            <!-- æŠ•æ‰‹ç‹€æ…‹ -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-red-400 flex items-center gap-2">
                    âš”ï¸ æŠ•æ‰‹ç‹€æ…‹
                    <div id="pitcher-status-indicator" class="w-3 h-3 rounded-full bg-red-500 animate-pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>ç”Ÿå‘½å€¼</span>
                        <span id="pitcher-hp" class="font-bold text-red-400">150/150</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="pitcher-hp-bar" class="bg-gradient-to-r from-red-500 to-red-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <div class="flex justify-between text-sm">
                        <span>æ”»æ“ŠåŠ›</span>
                        <span id="pitcher-attack" class="font-bold text-orange-400">30</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>å±¬æ€§</span>
                        <span id="pitcher-attribute" class="font-bold text-purple-400">å¤©</span>
                    </div>
                    
                    <div id="pitcher-debuffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>
        </div>

        <!-- æˆ°é¬¥å€åŸŸ -->
        <div class="bg-slate-800 p-6 rounded-xl mb-6">
            <h2 class="text-xl font-bold mb-6 text-center">âš”ï¸ æˆ°é¬¥å€åŸŸ</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <!-- æ‰“æ“Šå€ -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-red-300">ğŸ—¡ï¸ æ‰“æ“Šå€</h3>
                    <div id="strike-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="strike_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">ğŸ—¡ï¸</div>
                            <div class="text-sm">æ‹–æ‹½æ‰“è€…å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
                
                <!-- è¼”åŠ©å€ -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-blue-300">ğŸ›¡ï¸ è¼”åŠ©å€</h3>
                    <div id="support-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="support_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">ğŸ›¡ï¸</div>
                            <div class="text-sm">æ‹–æ‹½è¼”åŠ©å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
                
                <!-- æ³•è¡“å€ -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-purple-300">âœ¨ æ³•è¡“å€</h3>
                    <div id="spell-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="spell_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">âœ¨</div>
                            <div class="text-sm">æ‹–æ‹½æ³•è¡“å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æˆ°é¬¥æŒ‰éˆ•å€åŸŸ -->
            <div class="flex justify-center gap-4">
                <button id="attack-btn" class="px-8 py-4 bg-red-600 hover:bg-red-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    âš”ï¸ æ”»æ“Šï¼
                </button>
                <button id="end-turn-btn" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    ğŸ”„ çµæŸå›åˆ
                </button>
            </div>
        </div>

        <!-- æ‰‹ç‰Œå€åŸŸ -->
        <div class="bg-slate-800 p-4 rounded-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold">ğŸ´ æ‰‹ç‰Œ</h2>
                <div class="text-sm text-gray-400">
                    <span id="hand-count">0</span>/7 å¼µ
                </div>
            </div>
            <div id="hand-cards" class="flex gap-3 overflow-x-auto pb-2 min-h-[140px]">
                <!-- æ‰‹ç‰Œå°‡åœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </div>

        <!-- éŠæˆ²æ—¥èªŒ -->
        <div class="bg-slate-800 p-4 rounded-xl mt-6">
            <h2 class="text-lg font-bold mb-3 text-purple-400">ğŸ“œ æˆ°é¬¥æ—¥èªŒ</h2>
            <div id="game-log" class="h-32 overflow-y-auto space-y-1 text-sm bg-slate-900 p-3 rounded">
                <div class="text-green-400">ğŸš€ éŠæˆ²é–‹å§‹ï¼æ­¡è¿ä¾†åˆ° MyGO!!!!! Roguelike TCG v2</div>
            </div>
        </div>
    </main>

    <script>
        // ===== ğŸ“Š éŠæˆ²å¸¸æ•¸èˆ‡å¹³è¡¡ =====
        const GAME_BALANCE = {
            PLAYER_INITIAL_HP: 100,
            PITCHER_INITIAL_HP: 150,
            HAND_SIZE_LIMIT: 7,
            STRIKE_ZONE_LIMIT: 1,
            SUPPORT_ZONE_LIMIT: 1,
            SPELL_ZONE_LIMIT: 1,
            PITCHER_BASE_FATIGUE_RATE: 0.05,
            
            // æ•ˆæœæ•¸å€¼
            KINDNESS_BOOST: 10,
            DEMOCRACY_OUT_REDUCTION: 5,
            PATIENCE_DAMAGE_REDUCTION: 10,
            UNITY_BOOST: 8,
            PITCHER_ATTACK_REDUCTION: 3,
            
            // å±¬æ€§ç›¸é—œ
            ATTRIBUTE_TYPES: ['human', 'yin', 'yang', 'heaven', 'earth'],
            MIN_ATTRIBUTES_FOR_BONUS: 3
        };

        // ===== ğŸƒ å¡ç‰Œå¹³è¡¡æ•¸æ“š =====
        const CARD_BALANCE = {
            // äººå±¬ - æ™®é€š
            PRESIDENT: { hp: 10, attack: 15, crit: 35 },
            KINDNESS: { hp: 12, attack: 8, crit: 70 },
            HERO: { hp: 10, attack: 25, crit: 50 },
            LOTTERY: { hp: 8 },
            STRONGMAN: { hp: 15, attack: 18, crit: 50 },
            DEMOCRACY: { hp: 10, attack: 5, crit: 75 },
            CULTURE: { hp: 12 },
            PATIENCE: { hp: 10 },
            UNITY: { hp: 11 },
            LEGACY: { hp: 9, attack: 5, crit: 50 },
            SIMPLE_FOLK: { hp: 13, attack: 27, crit: 50 },
            FLESH: { hp: 20, attack: 8, crit: 50 },
            INHERITANCE: { hp: 10, attack: 8, crit: 35 },
            
            // äººå±¬ - ç¨€æœ‰
            HELP_STREAM: { hp: 12, attack: 5, crit: 35 },
            BENEVOLENT_LEGACY: { hp: 10, attack: 35, crit: 35 },
            COMMUNISM: { hp: 10 },
            MULTICULTURE: { hp: 10, attack: 10, crit: 70 },
            PROSPERITY: { hp: 10, attack: 8, crit: 25 },
            
            // äººå±¬ - å‚³èªª
            MASTER: { hp: 10, attack: 10, crit: 25 },
            HEAD_PAT: { hp: 15 },
            
            // é™°å±¬
            SHADOW_DEVOUR: { hp: 10, attack: 20, crit: 35 },
            LONE_SHADOW: { hp: 9 },
            EVIL_GENIUS: { hp: 14, attack: 15, crit: 35 },
            AMBUSH: { hp: 6, attack: 10, crit: 35 },
            TIME_STOP: { hp: 10 },
            
            // é™½å±¬
            WEAPON_MASTER: { hp: 8, attack: 8, crit: 70 },
            HOLY_LIGHT: { hp: 8 },
            LATE_GAME: { hp: 8, attack: 5, crit: 35 },
            YIN_YANG_HARMONY: { hp: 0, attack: 20, crit: 25 },
            RESURRECTION: { hp: 0, attack: 10, crit: 25 }
        };

        // ===== ğŸ® äº‹ä»¶ç³»çµ± =====
        class EventBus {
            constructor() {
                this.events = {};
            }
            
            on(event, callback) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(callback);
            }
            
            emit(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(callback => callback(data));
                }
            }
            
            off(event, callback) {
                if (this.events[event]) {
                    this.events[event] = this.events[event].filter(cb => cb !== callback);
                }
            }
        }

        // ===== ğŸƒ å¡ç‰Œè¨»å†Šç³»çµ± =====
        class CardRegistry {
            static cards = new Map();
            static initialized = false;
            
            static initialize() {
                if (this.initialized) return;
                
                console.log('ğŸƒ åˆå§‹åŒ–å¡ç‰Œè¨»å†Šç³»çµ±...');
                
                // è¨»å†Šæ‰€æœ‰å¡ç‰Œ
                this.registerAllCards();
                
                this.initialized = true;
                console.log(`âœ… æˆåŠŸè¨»å†Š ${this.cards.size} å¼µå¡ç‰Œ`);
            }
            
            static registerAllCards() {
                // äººå±¬ - æ™®é€š
                this.register('president', this.createPresidentCard);
                this.register('kindness', this.createKindnessCard);
                this.register('hero', this.createHeroCard);
                this.register('lottery', this.createLotteryCard);
                this.register('strongman', this.createStrongmanCard);
                this.register('democracy', this.createDemocracyCard);
                
                // é™°å±¬
                this.register('shadow_devour', this.createShadowDevourCard);
                this.register('lone_shadow', this.createLoneShadowCard);
                this.register('evil_genius', this.createEvilGeniusCard);
                
                // é™½å±¬
                this.register('weapon_master', this.createWeaponMasterCard);
                this.register('yinyang_harmony', this.createYinYangHarmonyCard);
                this.register('holy_light', this.createHolyLightCard);
            }
            
            static register(id, cardFactory) {
                this.cards.set(id, cardFactory);
            }
            
            static create(id) {
                if (!this.initialized) this.initialize();
                
                const cardFactory = this.cards.get(id);
                if (!cardFactory) {
                    throw new Error(`æœªæ‰¾åˆ°å¡ç‰Œ: ${id}`);
                }
                
                const card = cardFactory();
                card.cardId = id;
                return card;
            }
            
            // ===== ğŸ´ å¡ç‰Œå·¥å» æ–¹æ³• =====
            
            static createPresidentCard() {
                const balance = CARD_BALANCE.PRESIDENT;
                return {
                    id: 'president',
                    name: 'ç¸½çµ±',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'æ‰“æ“Šï¼šæ­¤å›åˆä¸­ï¼Œç‰Œçµ„è£¡æ¯æœ‰ä¸€å¼µäººå±¬æ€§å¡ï¼Œæ”»æ“ŠåŠ›+1',
                    effects: {
                        on_strike: async function(gameState) {
                            let humanCards = 0;
                            
                            // è¨ˆç®—æ‰‹ç‰Œä¸­çš„äººå±¬å¡
                            gameState.player.hand.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            
                            // è¨ˆç®—æ£„ç‰Œå †ä¸­çš„äººå±¬å¡
                            gameState.player.discard_pile.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + humanCards;
                            
                            return {
                                success: true,
                                description: `äººå±¬æ€§å¡æ•¸é‡: ${humanCards}ï¼Œæ”»æ“ŠåŠ›+${humanCards}`
                            };
                        }
                    }
                };
            }
            
            static createKindnessCard() {
                const balance = CARD_BALANCE.KINDNESS;
                return {
                    id: 'kindness',
                    name: 'æ…ˆæ„›',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'è¼”åŠ©ï¼šæ­¤å›åˆä¸­ï¼Œäººå±¬æ€§æ‰“è€…å¡æ”»æ“ŠåŠ›+10',
                    effects: {
                        on_support: async function(gameState) {
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 3;
                            
                            return {
                                success: true,
                                description: 'æŠ•æ‰‹æ”»æ“ŠåŠ›-3'
                            };
                        }
                    }
                };
            }
            
            static createLoneShadowCard() {
                const balance = CARD_BALANCE.LONE_SHADOW;
                return {
                    id: 'lone_shadow',
                    name: 'å­¤å½±',
                    type: 'spell',
                    attribute: 'yin',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp
                    },
                    description: 'æ¸›æŠ•æ‰‹5æ”»(æœ¬å›åˆ)ã€‚æŠ½1å¼µç‰Œ',
                    effects: {
                        on_play: async function(gameState) {
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 5;
                            
                            // æŠ½1å¼µç‰Œ
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                            }
                            
                            return {
                                success: true,
                                description: 'æŠ•æ‰‹æ”»æ“ŠåŠ›-5ï¼ŒæŠ½1å¼µç‰Œ'
                            };
                        }
                    }
                };
            }
            
            static createEvilGeniusCard() {
                const balance = CARD_BALANCE.EVIL_GENIUS;
                return {
                    id: 'evil_genius',
                    name: 'é‚ªæƒ¡å¤©æ‰',
                    type: 'batter',
                    attribute: 'yin',
                    rarity: 'rare',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'æ‰“æ“Šï¼šå¸å–æŠ•æ‰‹5é»æ”»æ“ŠåŠ›',
                    effects: {
                        on_strike: async function(gameState) {
                            // æ¸›å°‘æŠ•æ‰‹æ”»æ“ŠåŠ›
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 5;
                            
                            // å¢åŠ è‡ªå·±æ”»æ“ŠåŠ›
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + 5;
                            
                            return {
                                success: true,
                                description: 'å¸å–æŠ•æ‰‹5é»æ”»æ“ŠåŠ›'
                            };
                        }
                    }
                };
            }
            
            static createWeaponMasterCard() {
                const balance = CARD_BALANCE.WEAPON_MASTER;
                return {
                    id: 'weapon_master',
                    name: 'æ­¦å™¨å¤§å¸«',
                    type: 'batter',
                    attribute: 'yang',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'è¼”åŠ©ï¼šæ‰‹ç‰Œä¸­æ¯æœ‰ä¸€ç¨®ä¸åŒå±¬æ€§çš„å¡ï¼Œæ‰“è€…æ”»æ“ŠåŠ›+5',
                    effects: {
                        on_support: async function(gameState) {
                            const attributes = new Set();
                            gameState.player.hand.forEach(card => {
                                attributes.add(card.attribute);
                            });
                            
                            const boost = attributes.size * 5;
                            gameState.turnBuffs = gameState.turnBuffs || [];
                            gameState.turnBuffs.push({
                                type: 'batter_attack_boost',
                                value: boost,
                                source: this.name
                            });
                            
                            return {
                                success: true,
                                description: `æ‰‹ç‰Œ${attributes.size}ç¨®å±¬æ€§ï¼Œæ‰“è€…æ”»æ“ŠåŠ›+${boost}`
                            };
                        }
                    }
                };
            }
            
            static createYinYangHarmonyCard() {
                const balance = CARD_BALANCE.YIN_YANG_HARMONY;
                return {
                    id: 'yinyang_harmony',
                    name: 'é™°é™½èª¿å’Œ',
                    type: 'batter',
                    attribute: 'yang',
                    rarity: 'rare',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'æ‰“æ“Šï¼šè‹¥è¼”åŠ©æ ¼ç‚ºé™°å±¬æ€§ï¼Œæ”»æ“ŠåŠ›ç¿»å€',
                    effects: {
                        on_strike: async function(gameState) {
                            const supportCard = gameState.player.support_zone;
                            
                            if (supportCard && supportCard.attribute === 'yin') {
                                const currentAttack = this.stats.attack + (this.tempBonus?.attack || 0);
                                this.tempBonus = this.tempBonus || {};
                                this.tempBonus.attack = currentAttack;
                                
                                return {
                                    success: true,
                                    description: 'è¼”åŠ©æ ¼ç‚ºé™°å±¬æ€§ï¼Œæ”»æ“ŠåŠ›ç¿»å€ï¼'
                                };
                            }
                            
                            return {
                                success: false,
                                reason: 'è¼”åŠ©æ ¼ä¸æ˜¯é™°å±¬æ€§'
                            };
                        }
                    }
                };
            }
            
            static createHolyLightCard() {
                const balance = CARD_BALANCE.HOLY_LIGHT;
                return {
                    id: 'holy_light',
                    name: 'è–å…‰',
                    type: 'spell',
                    attribute: 'yang',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp
                    },
                    description: 'é¸æ“‡ä¸€å¼µæ‰‹ç‰Œï¼Œå…¶æ”»æ“ŠåŠ›+8(æœ¬å›åˆ)ã€‚æŠ½1å¼µç‰Œ',
                    effects: {
                        on_play: async function(gameState) {
                            // ç°¡åŒ–å¯¦ç¾ï¼šçµ¦ç¬¬ä¸€å¼µæ‰“è€…å¡+8æ”»æ“ŠåŠ›
                            const batterCard = gameState.player.hand.find(card => card.type === 'batter');
                            if (batterCard) {
                                batterCard.tempBonus = batterCard.tempBonus || {};
                                batterCard.tempBonus.attack = (batterCard.tempBonus.attack || 0) + 8;
                            }
                            
                            // æŠ½1å¼µç‰Œ
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                            }
                            
                            return {
                                success: true,
                                description: batterCard ? `${batterCard.name}æ”»æ“ŠåŠ›+8ï¼ŒæŠ½1å¼µç‰Œ` : 'æŠ½1å¼µç‰Œ'
                            };
                        }
                    }
                };
            }
            
            static getStats() {
                const stats = {
                    total: this.cards.size,
                    byAttribute: {},
                    byType: {},
                    byRarity: {}
                };
                
                for (const [id, cardFactory] of this.cards.entries()) {
                    try {
                        const card = cardFactory();
                        stats.byAttribute[card.attribute] = (stats.byAttribute[card.attribute] || 0) + 1;
                        stats.byType[card.type] = (stats.byType[card.type] || 0) + 1;
                        stats.byRarity[card.rarity] = (stats.byRarity[card.rarity] || 0) + 1;
                    } catch (error) {
                        console.warn(`çµ±è¨ˆå¡ç‰Œ ${id} æ™‚å‡ºéŒ¯:`, error);
                    }
                }
                
                return stats;
            }
        }

        // ===== ğŸ® éŠæˆ²ç‹€æ…‹ç®¡ç† =====
        class GameState {
            constructor() {
                this.player = {
                    current_hp: GAME_BALANCE.PLAYER_INITIAL_HP,
                    max_hp: GAME_BALANCE.PLAYER_INITIAL_HP,
                    deck: [],
                    hand: [],
                    discard_pile: [],
                    strike_zone: null,
                    support_zone: null,
                    spell_zone: null,
                    active_buffs: []
                };
                
                this.pitcher = {
                    current_hp: GAME_BALANCE.PITCHER_INITIAL_HP,
                    max_hp: GAME_BALANCE.PITCHER_INITIAL_HP,
                    base_attack: 30,
                    current_attack: 30,
                    attribute: 'heaven',
                    active_debuffs: []
                };
                
                this.gamePhase = 'DRAW_PHASE';
                this.turnCount = 1;
                this.turnBuffs = [];
                this.turnPlayedCards = [];
            }
        }

        // ===== âš”ï¸ æˆ°é¬¥ç³»çµ± =====
        class CombatSystem {
            constructor(eventBus) {
                this.eventBus = eventBus || new EventBus();
            }

            calculateDamage(gameState) {
                console.log('âš”ï¸ é–‹å§‹å‚·å®³è¨ˆç®—...');
                
                let totalAttack = 0;
                let totalCrit = 0;
                
                const strikeCard = gameState.player.strike_zone;
                const supportCard = gameState.player.support_zone;
                
                if (strikeCard) {
                    totalAttack += strikeCard.stats.attack;
                    totalCrit += strikeCard.stats.crit;
                    console.log(`ğŸ—¡ï¸ æ‰“æ“Šå€: ${strikeCard.name} - æ”»æ“Š:${strikeCard.stats.attack} æš´æ“Š:${strikeCard.stats.crit}`);
                }
                
                if (supportCard) {
                    totalAttack += supportCard.stats.attack;
                    totalCrit += supportCard.stats.crit;
                    console.log(`ğŸ›¡ï¸ è¼”åŠ©å€: ${supportCard.name} - æ”»æ“Š:${supportCard.stats.attack} æš´æ“Š:${supportCard.stats.crit}`);
                }

                // æ‡‰ç”¨å¡ç‰Œæ•ˆæœèˆ‡Buff
                const modifiedStats = this.applyEffectsAndBuffs(gameState, totalAttack, totalCrit, strikeCard, supportCard);
                totalAttack = modifiedStats.attack;
                totalCrit = modifiedStats.crit;
                
                console.log(`ğŸ’ª æ•ˆæœå¾Œæ•¸å€¼ - ç¸½æ”»æ“Š:${totalAttack} ç¸½æš´æ“Š:${totalCrit}`);

                // è¨ˆç®—æœ€çµ‚å‚·å®³
                let finalDamage = totalAttack * (1 + totalCrit / 100);
                console.log(`ğŸ§® æ ¸å¿ƒå…¬å¼: ${totalAttack} * (1 + ${totalCrit}/100) = ${finalDamage}`);

                // æ‡‰ç”¨å±¬æ€§å…‹åˆ¶
                const playerMainAttr = this.getPlayerMainAttribute(gameState);
                const pitcherAttr = gameState.pitcher.attribute;
                
                if (this.isStrongAgainst(playerMainAttr, pitcherAttr)) {
                    finalDamage *= 1.2;
                    console.log(`âš¡ å±¬æ€§å…‹åˆ¶: ${playerMainAttr} å…‹åˆ¶ ${pitcherAttr}, å‚·å®³ x1.2 = ${finalDamage}`);
                }

                finalDamage = Math.round(finalDamage);
                console.log(`ğŸ¯ æœ€çµ‚å‚·å®³: ${finalDamage}`);

                return {
                    finalDamage,
                    breakdown: {
                        baseAttack: totalAttack,
                        baseCrit: totalCrit,
                        critMultiplier: (1 + totalCrit / 100),
                        attributeBonus: this.isStrongAgainst(playerMainAttr, pitcherAttr) ? 1.2 : 1.0,
                        playerAttribute: playerMainAttr,
                        pitcherAttribute: pitcherAttr
                    }
                };
            }

            applyEffectsAndBuffs(gameState, baseAttack, baseCrit, strikeCard, supportCard) {
                let totalAttack = baseAttack;
                let totalCrit = baseCrit;

                // æ‡‰ç”¨æ‰“æ“Šå€å¡ç‰Œçš„è‡¨æ™‚åŠ æˆ
                if (strikeCard && strikeCard.tempBonus) {
                    if (strikeCard.tempBonus.attack) {
                        totalAttack += strikeCard.tempBonus.attack;
                        console.log(`âœ¨ ${strikeCard.name} è‡¨æ™‚æ”»æ“ŠåŠ›: +${strikeCard.tempBonus.attack}`);
                    }
                    if (strikeCard.tempBonus.crit) {
                        totalCrit += strikeCard.tempBonus.crit;
                        console.log(`âœ¨ ${strikeCard.name} è‡¨æ™‚æš´æ“Š: +${strikeCard.tempBonus.crit}`);
                    }
                }

                // æ‡‰ç”¨è¼”åŠ©å€å¡ç‰Œçš„è‡¨æ™‚åŠ æˆ
                if (supportCard && supportCard.tempBonus) {
                    if (supportCard.tempBonus.attack) {
                        totalAttack += supportCard.tempBonus.attack;
                        console.log(`âœ¨ ${supportCard.name} è‡¨æ™‚æ”»æ“ŠåŠ›: +${supportCard.tempBonus.attack}`);
                    }
                    if (supportCard.tempBonus.crit) {
                        totalCrit += supportCard.tempBonus.crit;
                        console.log(`âœ¨ ${supportCard.name} è‡¨æ™‚æš´æ“Š: +${supportCard.tempBonus.crit}`);
                    }
                }

                // æ‡‰ç”¨å…¨å±€Buff
                gameState.player.active_buffs?.forEach(buff => {
                    if (buff.type === 'ATTACK_UP') {
                        totalAttack += buff.value;
                        console.log(`ğŸ”¥ å…¨å±€Buff: æ”»æ“ŠåŠ› +${buff.value}`);
                    }
                    if (buff.type === 'CRIT_UP') {
                        totalCrit += buff.value;
                        console.log(`âš¡ å…¨å±€Buff: æš´æ“Š +${buff.value}`);
                    }
                });

                // æ‡‰ç”¨å›åˆBuff
                gameState.turnBuffs?.forEach(buff => {
                    if (buff.type === 'human_batter_attack_boost' && strikeCard?.attribute === 'human') {
                        totalAttack += buff.value;
                        console.log(`ğŸ’ ${buff.source}: äººå±¬æ‰“è€…æ”»æ“ŠåŠ› +${buff.value}`);
                    }
                    if (buff.type === 'batter_attack_boost' && strikeCard?.type === 'batter') {
                        totalAttack += buff.value;
                        console.log(`âš”ï¸ ${buff.source}: æ‰“è€…æ”»æ“ŠåŠ› +${buff.value}`);
                    }
                });

                return { attack: totalAttack, crit: totalCrit };
            }

            isStrongAgainst(playerAttr, enemyAttr) {
                const advantages = {
                    'human': ['yin'],
                    'yin': ['yang'], 
                    'yang': ['heaven'],
                    'heaven': ['earth'],
                    'earth': ['human']
                };
                
                return advantages[playerAttr]?.includes(enemyAttr) || false;
            }

            getPlayerMainAttribute(gameState) {
                if (gameState.player.strike_zone) {
                    return gameState.player.strike_zone.attribute;
                }
                
                if (gameState.player.support_zone) {
                    return gameState.player.support_zone.attribute;
                }
                
                return 'human';
            }

            async executeCombat(gameState) {
                console.log('ğŸ® é–‹å§‹æˆ°é¬¥éšæ®µ...');
                
                if (!gameState.player.strike_zone) {
                    return { success: false, reason: 'æ‰“æ“Šå€æ²’æœ‰å¡ç‰Œ' };
                }

                // è§¸ç™¼æ‰“æ“Šå€å¡ç‰Œçš„ on_strike æ•ˆæœ
                const strikeCard = gameState.player.strike_zone;
                if (strikeCard.effects?.on_strike) {
                    console.log(`ğŸ¯ è§¸ç™¼ ${strikeCard.name} çš„æ‰“æ“Šæ•ˆæœ`);
                    const effectResult = await strikeCard.effects.on_strike.call(strikeCard, gameState);
                    if (effectResult.success) {
                        console.log(`âœ… æ‰“æ“Šæ•ˆæœ: ${effectResult.description}`);
                    }
                }

                // è§¸ç™¼è¼”åŠ©å€å¡ç‰Œçš„ on_support æ•ˆæœ
                const supportCard = gameState.player.support_zone;
                if (supportCard?.effects?.on_support) {
                    console.log(`ğŸ›¡ï¸ è§¸ç™¼ ${supportCard.name} çš„è¼”åŠ©æ•ˆæœ`);
                    const supportResult = await supportCard.effects.on_support.call(supportCard, gameState);
                    if (supportResult.success) {
                        console.log(`âœ… è¼”åŠ©æ•ˆæœ: ${supportResult.description}`);
                    }
                }

                // è¨ˆç®—å‚·å®³
                const damageResult = this.calculateDamage(gameState);
                
                // å°æŠ•æ‰‹é€ æˆå‚·å®³
                gameState.pitcher.current_hp -= damageResult.finalDamage;
                gameState.pitcher.current_hp = Math.max(0, gameState.pitcher.current_hp);
                
                // ç™¼å‡ºäº‹ä»¶
                this.eventBus.emit('damage_dealt', {
                    damage: damageResult.finalDamage,
                    breakdown: damageResult.breakdown,
                    pitcherHP: gameState.pitcher.current_hp,
                    pitcherMaxHP: gameState.pitcher.max_hp
                });

                // ç©å®¶å—åˆ°æŠ•æ‰‹æ”»æ“Š
                const pitcherDamage = this.calculatePitcherDamage(gameState);
                gameState.player.current_hp -= pitcherDamage;
                gameState.player.current_hp = Math.max(0, gameState.player.current_hp);

                console.log(`ğŸ¯ æˆ°é¬¥çµæœ: å°æŠ•æ‰‹é€ æˆ${damageResult.finalDamage}å‚·å®³, å—åˆ°${pitcherDamage}å‚·å®³`);

                return {
                    success: true,
                    playerDamageDealt: damageResult.finalDamage,
                    playerDamageReceived: pitcherDamage,
                    damageBreakdown: damageResult.breakdown
                };
            }

            calculatePitcherDamage(gameState) {
                let pitcherDamage = gameState.pitcher.current_attack;
                
                // æ‡‰ç”¨æŠ•æ‰‹çš„è‡¨æ™‚æ¸›ç›Š
                if (gameState.pitcher.tempDebuff?.attack) {
                    pitcherDamage += gameState.pitcher.tempDebuff.attack;
                    console.log(`ğŸ”» æŠ•æ‰‹æ”»æ“ŠåŠ›æ¸›ç›Š: ${gameState.pitcher.tempDebuff.attack}`);
                }

                // æ‡‰ç”¨å±¬æ€§å…‹åˆ¶
                const playerAttr = this.getPlayerMainAttribute(gameState);
                const pitcherAttr = gameState.pitcher.attribute;
                
                if (this.isStrongAgainst(pitcherAttr, playerAttr)) {
                    pitcherDamage *= 0.8;
                    console.log(`ğŸ›¡ï¸ ç©å®¶è¢«å…‹åˆ¶ï¼Œå‚·å®³æ¸›å°‘20%: ${pitcherDamage}`);
                }

                return Math.round(pitcherDamage);
            }

            applyPitcherFatigue(gameState) {
                const fatigueRate = GAME_BALANCE.PITCHER_BASE_FATIGUE_RATE;
                
                gameState.pitcher.current_attack *= (1 - fatigueRate);
                gameState.pitcher.current_attack = Math.round(gameState.pitcher.current_attack);
                
                console.log(`ğŸ˜´ æŠ•æ‰‹ç–²å‹: æ”»æ“ŠåŠ›é™è‡³ ${gameState.pitcher.current_attack} (ç–²å‹ç‡: ${fatigueRate * 100}%)`);
                
                this.eventBus.emit('pitcher_fatigue', {
                    newAttack: gameState.pitcher.current_attack,
                    fatigueRate: fatigueRate
                });
            }
        }

        // ===== ğŸ¯ å›åˆç³»çµ± =====
        class TurnSystem {
            constructor(eventBus) {
                this.eventBus = eventBus || new EventBus();
            }

            async processTurn(gameState) {
                console.log(`ğŸ”„ é–‹å§‹ç¬¬ ${gameState.turnCount} å›åˆ...`);
                
                try {
                    // 1. å›åˆé–‹å§‹
                    await this.startOfTurn(gameState);
                    
                    // 2. æŠ½ç‰Œéšæ®µ
                    await this.drawPhase(gameState);
                    
                    // 3. å‡ºç‰Œéšæ®µ
                    gameState.gamePhase = 'PLAY_PHASE';
                    this.eventBus.emit('turn_phase_changed', { phase: 'PLAY_PHASE' });
                    
                } catch (error) {
                    console.error('âŒ å›åˆè™•ç†å¤±æ•—:', error);
                    this.eventBus.emit('turn_error', { error: error.message });
                }
            }

            async startOfTurn(gameState) {
                console.log('ğŸŒ… å›åˆé–‹å§‹éšæ®µ...');
                
                // è™•ç†Buff/Debuffçš„æŒçºŒæ™‚é–“
                this.updateBuffDurations(gameState.player.active_buffs);
                this.updateBuffDurations(gameState.pitcher.active_debuffs);
                
                this.eventBus.emit('turn_start', { gameState });
            }

            async drawPhase(gameState) {
                console.log('ğŸ´ æŠ½ç‰Œéšæ®µ...');
                
                const handSizeLimit = GAME_BALANCE.HAND_SIZE_LIMIT;
                const drawCount = handSizeLimit - gameState.player.hand.length;
                
                console.log(`ğŸ“‹ ç•¶å‰æ‰‹ç‰Œ: ${gameState.player.hand.length}, éœ€æŠ½ç‰Œ: ${drawCount}`);
                
                for (let i = 0; i < drawCount; i++) {
                    if (!this.drawSingleCard(gameState)) {
                        console.log('âš ï¸ ç„¡æ³•ç¹¼çºŒæŠ½ç‰Œ');
                        break;
                    }
                }
                
                this.eventBus.emit('draw_phase_complete', { 
                    drawnCards: drawCount,
                    handSize: gameState.player.hand.length 
                });
            }

            drawSingleCard(gameState) {
                // å¦‚æœç‰Œåº«ç‚ºç©ºï¼Œé‡æ–°æ´—ç‰Œ
                if (gameState.player.deck.length === 0) {
                    if (gameState.player.discard_pile.length === 0) {
                        console.log('ğŸ“š ç‰Œåº«å’Œæ£„ç‰Œå †éƒ½æ˜¯ç©ºçš„ï¼Œç„¡æ³•æŠ½ç‰Œ');
                        return false;
                    }
                    
                    console.log('ğŸ”€ ç‰Œåº«ç‚ºç©ºï¼Œé‡æ–°æ´—ç‰Œ...');
                    gameState.player.deck = [...gameState.player.discard_pile];
                    gameState.player.discard_pile = [];
                    this.shuffleDeck(gameState.player.deck);
                    
                    this.eventBus.emit('deck_shuffled', { deckSize: gameState.player.deck.length });
                }
                
                if (gameState.player.deck.length > 0) {
                    const card = gameState.player.deck.pop();
                    gameState.player.hand.push(card);
                    console.log(`ğŸ´ æŠ½åˆ°: ${card.name}`);
                    
                    this.eventBus.emit('card_drawn', { card });
                    return true;
                }
                
                return false;
            }

            async combatPhase(gameState, combatSystem) {
                console.log('âš”ï¸ æˆ°é¬¥éšæ®µ...');
                gameState.gamePhase = 'COMBAT_PHASE';
                
                const combatResult = await combatSystem.executeCombat(gameState);
                
                this.eventBus.emit('combat_complete', { result: combatResult });
                
                return combatResult;
            }

            async endOfTurn(gameState, combatSystem) {
                console.log('ğŸŒ™ å›åˆçµæŸéšæ®µ...');
                
                // å°‡å ´ä¸Šå¡ç‰Œç§»å…¥æ£„ç‰Œå †
                this.moveCardsToDiscard(gameState);
                
                // æŠ•æ‰‹ç–²å‹
                combatSystem.applyPitcherFatigue(gameState);
                
                // æª¢æŸ¥å‹è² 
                const gameOver = this.checkGameEnd(gameState);
                
                // æ¸…ç†è‡¨æ™‚æ•ˆæœ
                this.cleanupTurnBuffs(gameState);
                
                // å¢åŠ å›åˆè¨ˆæ•¸
                gameState.turnCount++;
                
                this.eventBus.emit('turn_end', { gameState, gameOver });
                
                return gameOver;
            }

            moveCardsToDiscard(gameState) {
                const zones = ['strike_zone', 'support_zone', 'spell_zone'];
                
                zones.forEach(zone => {
                    if (gameState.player[zone]) {
                        const card = gameState.player[zone];
                        gameState.player.discard_pile.push(card);
                        gameState.player[zone] = null;
                        console.log(`ğŸ—‚ï¸ ${card.name} ç§»å…¥æ£„ç‰Œå †`);
                    }
                });
            }

            updateBuffDurations(buffs) {
                if (!Array.isArray(buffs)) return;
                
                for (let i = buffs.length - 1; i >= 0; i--) {
                    const buff = buffs[i];
                    if (buff.duration > 0) {
                        buff.duration--;
                        if (buff.duration === 0) {
                            console.log(`â° BufféæœŸ: ${buff.type}`);
                            buffs.splice(i, 1);
                        }
                    }
                }
            }

            cleanupTurnBuffs(gameState) {
                gameState.turnBuffs = [];
                gameState.turnPlayedCards = [];
                
                // æ¸…ç†å¡ç‰Œçš„è‡¨æ™‚åŠ æˆ
                [...gameState.player.hand, ...gameState.player.discard_pile].forEach(card => {
                    if (card.tempBonus) {
                        delete card.tempBonus;
                    }
                });
                
                // æ¸…ç†æŠ•æ‰‹çš„è‡¨æ™‚æ¸›ç›Š
                if (gameState.pitcher.tempDebuff) {
                    delete gameState.pitcher.tempDebuff;
                }
            }

            checkGameEnd(gameState) {
                if (gameState.player.current_hp <= 0) {
                    return { gameOver: true, winner: 'pitcher', reason: 'ç©å®¶è¡€é‡æ­¸é›¶' };
                }
                
                if (gameState.pitcher.current_hp <= 0) {
                    return { gameOver: true, winner: 'player', reason: 'æŠ•æ‰‹è¡€é‡æ­¸é›¶' };
                }
                
                return { gameOver: false };
            }

            shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }
        }

        // ===== ğŸ¨ UI ç®¡ç†ç³»çµ± =====
        class UIManager {
            constructor() {
                this.elements = {};
                this.initializeElements();
            }
            
            initializeElements() {
                this.elements = {
                    // ç‹€æ…‹é¡¯ç¤º
                    playerHp: document.getElementById('player-hp'),
                    playerHpBar: document.getElementById('player-hp-bar'),
                    pitcherHp: document.getElementById('pitcher-hp'),
                    pitcherHpBar: document.getElementById('pitcher-hp-bar'),
                    pitcherAttack: document.getElementById('pitcher-attack'),
                    pitcherAttribute: document.getElementById('pitcher-attribute'),
                    
                    // è¨ˆæ•¸å™¨
                    turnCounter: document.getElementById('turn-counter'),
                    deckCount: document.getElementById('deck-count'),
                    discardCount: document.getElementById('discard-count'),
                    handCount: document.getElementById('hand-count'),
                    
                    // å€åŸŸ
                    strikeZone: document.getElementById('strike-zone'),
                    supportZone: document.getElementById('support-zone'),
                    spellZone: document.getElementById('spell-zone'),
                    handCards: document.getElementById('hand-cards'),
                    
                    // æ§åˆ¶
                    gamePhase: document.getElementById('game-phase'),
                    phaseDescription: document.getElementById('phase-description'),
                    gameLog: document.getElementById('game-log'),
                    
                    // æŒ‰éˆ•
                    attackBtn: document.getElementById('attack-btn'),
                    endTurnBtn: document.getElementById('end-turn-btn'),
                    resetBtn: document.getElementById('reset-btn')
                };
                
                return Object.values(this.elements).every(el => el !== null);
            }
            
            static generateCardClasses(attribute, rarity) {
                const baseClasses = 'w-28 h-36 rounded-xl p-3 text-xs cursor-pointer card-hover flex flex-col justify-between';
                
                const attributeColors = {
                    human: { base: 'human-base', dark: 'human-dark', text: 'human-text' },
                    yin: { base: 'yin-base', dark: 'yin-dark', text: 'yin-text' },
                    yang: { base: 'yang-base', dark: 'yang-dark', text: 'yang-text' },
                    heaven: { base: 'heaven-base', dark: 'heaven-dark', text: 'heaven-text' },
                    earth: { base: 'earth-base', dark: 'earth-dark', text: 'earth-text' }
                };
                
                const rarityStyles = {
                    common: (colors) => `bg-${colors.base}`,
                    rare: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-lg`,
                    legendary: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-xl ring-2 ring-legendary-ring animate-glow`
                };
                
                const colors = attributeColors[attribute] || attributeColors.human;
                const backgroundStyle = rarityStyles[rarity](colors);
                
                return `${baseClasses} ${backgroundStyle} text-${colors.text}`;
            }

            static renderCard(cardData, index, showDetails = true) {
                const cardClasses = this.generateCardClasses(cardData.attribute, cardData.rarity);
                
                return `
                    <div class="${cardClasses} animate-card-draw" draggable="true" data-card-index="${index}" style="animation-delay: ${index * 0.1}s">
                        <div class="text-center mb-2">
                            <div class="font-bold text-sm mb-1">${cardData.name}</div>
                            <div class="text-[10px] opacity-80 bg-black/20 px-2 py-1 rounded">${cardData.attribute} â€¢ ${cardData.type}</div>
                        </div>
                        
                        ${showDetails ? `
                        <div class="flex-1 text-[10px] leading-tight opacity-90">
                            ${cardData.description}
                        </div>
                        ` : ''}
                        
                        <div class="flex justify-between text-[11px] font-bold mt-2 bg-black/20 p-1 rounded">
                            <span title="æ”»æ“ŠåŠ›">âš”ï¸${cardData.stats.attack || 0}</span>
                            <span title="æš´æ“Šå€¼">ğŸ’${cardData.stats.crit || 0}</span>
                        </div>
                    </div>
                `;
            }

            static showFloatingText(element, text, type = 'damage') {
                const floatingText = document.createElement('div');
                floatingText.className = `floating-text animate-${type}`;
                floatingText.textContent = text;
                
                const rect = element.getBoundingClientRect();
                floatingText.style.left = `${rect.left + rect.width / 2 - 20}px`;
                floatingText.style.top = `${rect.top}px`;
                
                document.body.appendChild(floatingText);
                
                setTimeout(() => {
                    if (document.body.contains(floatingText)) {
                        document.body.removeChild(floatingText);
                    }
                }, 1500);
            }

            addLogEntry(message, type = 'info') {
                const logContainer = this.elements.gameLog;
                const logEntry = document.createElement('div');
                
                const colors = {
                    info: 'text-gray-300',
                    success: 'text-green-400',
                    damage: 'text-red-400',
                    heal: 'text-green-400',
                    system: 'text-blue-400',
                    warning: 'text-yellow-400'
                };
                
                logEntry.className = colors[type] || colors.info;
                logEntry.innerHTML = `<span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            updatePhaseDisplay(phase) {
                const phaseData = {
                    'DRAW_PHASE': { name: 'æŠ½ç‰Œéšæ®µ', description: 'è£œå……æ‰‹ç‰Œè‡³7å¼µ', color: 'bg-blue-600' },
                    'PLAY_PHASE': { name: 'å‡ºç‰Œéšæ®µ', description: 'æ‹–æ‹½å¡ç‰Œåˆ°æˆ°é¬¥å€åŸŸ', color: 'bg-green-600' },
                    'COMBAT_PHASE': { name: 'æˆ°é¬¥éšæ®µ', description: 'è¨ˆç®—å‚·å®³ä¸¦åŸ·è¡Œæ”»æ“Š', color: 'bg-red-600' }
                };
                
                const data = phaseData[phase];
                if (data) {
                    this.elements.gamePhase.textContent = data.name;
                    this.elements.gamePhase.className = `text-center py-3 px-4 rounded-lg font-bold text-white ${data.color}`;
                    this.elements.phaseDescription.textContent = data.description;
                }
            }

            updateUI(gameState) {
                this.updateHandDisplay(gameState);
                this.updateBattleZones(gameState);
                this.updateStatusDisplay(gameState);
                this.updateCounters(gameState);
                this.updatePhaseDisplay(gameState.gamePhase);
            }
            
            updateHandDisplay(gameState) {
                if (!this.elements.handCards) return;
                
                this.elements.handCards.innerHTML = gameState.player.hand
                    .map((card, index) => UIManager.renderCard(card, index))
                    .join('');
                
                if (this.elements.handCount) {
                    this.elements.handCount.textContent = gameState.player.hand.length;
                }
                
                // é‡æ–°ç¶å®šæ‹–æ‹½äº‹ä»¶
                this.bindCardDragEvents();
            }
            
            bindCardDragEvents() {
                const cards = document.querySelectorAll('[data-card-index]');
                cards.forEach(card => {
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', e.target.dataset.cardIndex);
                    });
                });
            }
            
            updateBattleZones(gameState) {
                const zones = [
                    { id: 'strike-zone', state: 'strike_zone', icon: 'ğŸ—¡ï¸', name: 'æ‰“æ“Š' },
                    { id: 'support-zone', state: 'support_zone', icon: 'ğŸ›¡ï¸', name: 'è¼”åŠ©' },
                    { id: 'spell-zone', state: 'spell_zone', icon: 'âœ¨', name: 'æ³•è¡“' }
                ];
                
                zones.forEach(({ id, state, icon, name }) => {
                    const zoneElement = document.getElementById(id);
                    if (!zoneElement) return;
                    
                    const card = gameState.player[state];
                    
                    if (card) {
                        zoneElement.innerHTML = UIManager.renderCard(card, -1, false);
                        zoneElement.classList.add('card-zone-occupied');
                    } else {
                        zoneElement.innerHTML = `
                            <div class="text-center text-gray-400">
                                <div class="text-3xl mb-2">${icon}</div>
                                <div class="text-sm">æ‹–æ‹½${name}å¡åˆ°æ­¤è™•</div>
                            </div>
                        `;
                        zoneElement.classList.remove('card-zone-occupied');
                    }
                });
            }
            
            updateStatusDisplay(gameState) {
                // æ›´æ–°ç©å®¶ç‹€æ…‹
                if (this.elements.playerHp) {
                    this.elements.playerHp.textContent = 
                        `${gameState.player.current_hp}/${gameState.player.max_hp}`;
                }
                if (this.elements.playerHpBar) {
                    this.elements.playerHpBar.style.width = 
                        `${(gameState.player.current_hp / gameState.player.max_hp) * 100}%`;
                }
                
                // æ›´æ–°æŠ•æ‰‹ç‹€æ…‹
                if (this.elements.pitcherHp) {
                    this.elements.pitcherHp.textContent = 
                        `${gameState.pitcher.current_hp}/${gameState.pitcher.max_hp}`;
                }
                if (this.elements.pitcherHpBar) {
                    this.elements.pitcherHpBar.style.width = 
                        `${(gameState.pitcher.current_hp / gameState.pitcher.max_hp) * 100}%`;
                }
                if (this.elements.pitcherAttack) {
                    this.elements.pitcherAttack.textContent = gameState.pitcher.current_attack;
                }
                if (this.elements.pitcherAttribute) {
                    this.elements.pitcherAttribute.textContent = gameState.pitcher.attribute;
                }
            }
            
            updateCounters(gameState) {
                if (this.elements.turnCounter) {
                    this.elements.turnCounter.textContent = gameState.turnCount;
                }
                if (this.elements.deckCount) {
                    this.elements.deckCount.textContent = gameState.player.deck.length;
                }
                if (this.elements.discardCount) {
                    this.elements.discardCount.textContent = gameState.player.discard_pile.length;
                }
            }
        }

        // ===== ğŸ® éŠæˆ²æ§åˆ¶å™¨ =====
        class GameController {
            constructor() {
                console.log('ğŸ® åˆå§‹åŒ–éŠæˆ²æ§åˆ¶å™¨...');
                
                this.eventBus = new EventBus();
                this.gameState = new GameState();
                this.combatSystem = new CombatSystem(this.eventBus);
                this.turnSystem = new TurnSystem(this.eventBus);
                this.uiManager = new UIManager();
                
                CardRegistry.initialize();
                this.setupEventListeners();
                this.isGameRunning = false;
                
                console.log('âœ… éŠæˆ²æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ');
            }

            setupEventListeners() {
                // æ”»æ“ŠæŒ‰éˆ•
                if (this.uiManager.elements.attackBtn) {
                    this.uiManager.elements.attackBtn.addEventListener('click', () => {
                        this.executeAttack();
                    });
                }
                
                // çµæŸå›åˆæŒ‰éˆ•
                if (this.uiManager.elements.endTurnBtn) {
                    this.uiManager.elements.endTurnBtn.addEventListener('click', () => {
                        this.endTurn();
                    });
                }
                
                // é‡ç½®æŒ‰éˆ•
                if (this.uiManager.elements.resetBtn) {
                    this.uiManager.elements.resetBtn.addEventListener('click', () => {
                        if (confirm('ç¢ºå®šè¦é‡ç½®éŠæˆ²å—ï¼Ÿ')) {
                            this.resetGame();
                        }
                    });
                }
                
                // è¨­ç½®æ‹–æ”¾
                this.setupDragAndDrop();
                
                // è¨­ç½®äº‹ä»¶ç›£è½
                this.eventBus.on('damage_dealt', (data) => {
                    this.uiManager.addLogEntry(`ğŸ’¥ é€ æˆå‚·å®³: ${data.damage}`, 'damage');
                    UIManager.showFloatingText(this.uiManager.elements.pitcherHpBar, `-${data.damage}`, 'damage');
                    this.uiManager.elements.pitcherHpBar.classList.add('animate-shake');
                    setTimeout(() => {
                        this.uiManager.elements.pitcherHpBar.classList.remove('animate-shake');
                    }, 500);
                });

                this.eventBus.on('turn_phase_changed', (data) => {
                    this.uiManager.updatePhaseDisplay(data.phase);
                });

                this.eventBus.on('card_drawn', (data) => {
                    this.uiManager.addLogEntry(`ğŸ´ æŠ½åˆ°: ${data.card.name}`, 'success');
                });
            }
            
            setupDragAndDrop() {
                const zones = ['strike-zone', 'support-zone', 'spell-zone'];
                
                zones.forEach(zoneId => {
                    const zone = document.getElementById(zoneId);
                    if (!zone) return;
                    
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        zone.classList.add('drag-over');
                    });

                    zone.addEventListener('dragleave', () => {
                        zone.classList.remove('drag-over');
                    });

                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.classList.remove('drag-over');
                        
                        const cardIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const targetZone = zone.dataset.zone || zoneId.replace('-', '_');
                        
                        this.playCard(cardIndex, targetZone);
                    });
                });
            }
            
            async playCard(cardIndex, targetZone) {
                const card = this.gameState.player.hand[cardIndex];
                if (!card) {
                    this.uiManager.addLogEntry('âŒ ç„¡æ•ˆçš„å¡ç‰Œç´¢å¼•', 'damage');
                    return;
                }

                // æª¢æŸ¥éŠæˆ²éšæ®µ
                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    this.uiManager.addLogEntry('âŒ ä¸åœ¨å‡ºç‰Œéšæ®µï¼', 'damage');
                    return;
                }

                // æª¢æŸ¥å€åŸŸæ˜¯å¦å·²æœ‰å¡ç‰Œ
                if (this.gameState.player[targetZone]) {
                    this.uiManager.addLogEntry('âŒ è©²å€åŸŸå·²æœ‰å¡ç‰Œï¼', 'damage');
                    return;
                }

                // æª¢æŸ¥å¡ç‰Œé¡å‹æ˜¯å¦åŒ¹é…
                const validPlacements = {
                    'strike_zone': ['batter'],
                    'support_zone': ['batter', 'support'],
                    'spell_zone': ['spell']
                };

                if (!validPlacements[targetZone].includes(card.type)) {
                    this.uiManager.addLogEntry('âŒ å¡ç‰Œé¡å‹ä¸åŒ¹é…ï¼', 'damage');
                    return;
                }

                // æ”¾ç½®å¡ç‰Œ
                this.gameState.player[targetZone] = card;
                this.gameState.player.hand.splice(cardIndex, 1);

                // è¨˜éŒ„æœ¬å›åˆæ‰“å‡ºçš„å¡ç‰Œ
                this.gameState.turnPlayedCards.push(card);

                // è§¸ç™¼æ‰“å‡ºæ™‚æ•ˆæœ
                if (card.effects?.on_play) {
                    const result = await card.effects.on_play.call(card, this.gameState);
                    if (result.success) {
                        this.uiManager.addLogEntry(`âœ¨ ${result.description}`, 'success');
                    }
                }

                const zoneNames = {
                    'strike_zone': 'æ‰“æ“Šå€',
                    'support_zone': 'è¼”åŠ©å€', 
                    'spell_zone': 'æ³•è¡“å€'
                };

                this.uiManager.addLogEntry(`ğŸ´ ${card.name} æ”¾ç½®åˆ°${zoneNames[targetZone]}`, 'success');
                this.uiManager.updateUI(this.gameState);
            }
            
            async executeAttack() {
                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    this.uiManager.addLogEntry('âŒ ä¸åœ¨å‡ºç‰Œéšæ®µï¼', 'damage');
                    return;
                }
                
                if (!this.gameState.player.strike_zone) {
                    this.uiManager.addLogEntry('âŒ è«‹å…ˆæ”¾ç½®æ‰“æ“Šå¡ç‰Œï¼', 'damage');
                    return;
                }
                
                // åˆ‡æ›åˆ°æˆ°é¬¥éšæ®µ
                this.gameState.gamePhase = 'COMBAT_PHASE';
                this.uiManager.updatePhaseDisplay(this.gameState.gamePhase);
                
                // åŸ·è¡Œæˆ°é¬¥
                this.uiManager.addLogEntry('âš”ï¸ æˆ°é¬¥é–‹å§‹ï¼', 'system');
                
                const combatResult = await this.turnSystem.combatPhase(this.gameState, this.combatSystem);
                
                // æª¢æŸ¥å‹è² 
                if (this.gameState.pitcher.current_hp <= 0) {
                    this.uiManager.addLogEntry('ğŸ† å‹åˆ©ï¼æŠ•æ‰‹è¢«æ“Šæ•—äº†ï¼', 'success');
                    setTimeout(() => {
                        alert('ğŸ‰ æ­å–œå‹åˆ©ï¼\n\nåœ¨å®Œæ•´ç‰ˆæœ¬ä¸­ï¼Œé€™è£¡å°‡é€²å…¥çå‹µé¸æ“‡éšæ®µã€‚');
                    }, 1000);
                    this.uiManager.updateUI(this.gameState);
                    return;
                }
                
                // æŠ•æ‰‹åæ“Š
                setTimeout(() => {
                    this.pitcherAttack();
                }, 1000);
                
                this.uiManager.updateUI(this.gameState);
            }
            
            pitcherAttack() {
                const pitcherDamage = this.combatSystem.calculatePitcherDamage(this.gameState);
                
                this.gameState.player.current_hp -= pitcherDamage;
                this.gameState.player.current_hp = Math.max(0, this.gameState.player.current_hp);
                
                this.uiManager.addLogEntry(`ğŸ’¢ æŠ•æ‰‹åæ“Šï¼å—åˆ° ${pitcherDamage} é»å‚·å®³ï¼`, 'damage');
                UIManager.showFloatingText(this.uiManager.elements.playerHpBar, `-${pitcherDamage}`, 'damage');
                
                // éœ‡å‹•æ•ˆæœ
                this.uiManager.elements.playerHpBar.classList.add('animate-shake');
                setTimeout(() => {
                    this.uiManager.elements.playerHpBar.classList.remove('animate-shake');
                }, 500);
                
                // æª¢æŸ¥ç©å®¶æ˜¯å¦è¢«æ“Šæ•—
                if (this.gameState.player.current_hp <= 0) {
                    this.uiManager.addLogEntry('ğŸ’€ å¤±æ•—ï¼ä½ è¢«æ“Šæ•—äº†ï¼', 'damage');
                    setTimeout(() => {
                        alert('ğŸ’€ éŠæˆ²çµæŸï¼\n\né»æ“Šé‡ç½®é–‹å§‹æ–°éŠæˆ²ã€‚');
                    }, 1000);
                    this.uiManager.updateUI(this.gameState);
                    return;
                }
                
                this.uiManager.updateUI(this.gameState);
                
                // è‡ªå‹•çµæŸå›åˆ
                setTimeout(() => {
                    this.endTurn();
                }, 1500);
            }
            
            async endTurn() {
                const gameOver = await this.turnSystem.endOfTurn(this.gameState, this.combatSystem);
                
                if (gameOver.gameOver) {
                    this.uiManager.addLogEntry(`ğŸ† éŠæˆ²çµæŸ: ${gameOver.winner} ç²å‹ (${gameOver.reason})`, 'success');
                    return;
                }
                
                // é–‹å§‹æ–°å›åˆ
                setTimeout(() => {
                    this.turnSystem.processTurn(this.gameState);
                    this.uiManager.updateUI(this.gameState);
                }, 1000);
            }
            
            resetGame() {
                this.gameState = new GameState();
                this.uiManager.elements.gameLog.innerHTML = '';
                this.startGame();
                this.uiManager.addLogEntry('ğŸ”„ éŠæˆ²å·²é‡ç½®', 'system');
            }
            
            startGame() {
                console.log('ğŸš€ éŠæˆ²é–‹å§‹ï¼');
                
                // åˆå§‹åŒ–æ¸¬è©¦ç‰Œçµ„
                this.initializeDeck();
                
                // é–‹å§‹ç¬¬ä¸€å›åˆ
                this.turnSystem.processTurn(this.gameState);
                
                this.uiManager.addLogEntry('ğŸš€ éŠæˆ²é–‹å§‹ï¼æ­¡è¿ä¾†åˆ° MyGO!!!!! Roguelike TCG v2', 'success');
                this.uiManager.addLogEntry('ğŸ’¡ æç¤ºï¼šå°‡å¡ç‰Œæ‹–æ‹½åˆ°æˆ°é¬¥å€åŸŸï¼Œç„¶å¾Œé»æ“Šæ”»æ“Šï¼', 'system');
                
                this.uiManager.updateUI(this.gameState);
            }
            
            initializeDeck() {
                // å‰µå»ºæ¸¬è©¦ç‰Œçµ„
                const testDeckIds = [
                    'president', 'president', 'kindness', 'kindness', 
                    'hero', 'hero', 'hero', 'shadow_devour', 'yinyang_harmony',
                    'lottery', 'strongman', 'democracy', 'weapon_master', 'holy_light', 'evil_genius'
                ];

                // è½‰æ›ç‚ºå®Œæ•´å¡ç‰Œå°è±¡
                this.gameState.player.deck = testDeckIds.map(id => CardRegistry.create(id));
                this.turnSystem.shuffleDeck(this.gameState.player.deck);
                
                console.log(`ğŸ´ ç‰Œçµ„åˆå§‹åŒ–å®Œæˆ: ${this.gameState.player.deck.length} å¼µå¡ç‰Œ`);
            }
            
            getGameState() {
                return { ...this.gameState };
            }
        }

        // ===== ğŸš€ ä¸»æ‡‰ç”¨ç¨‹åº =====
        class MyGoTCGApplication {
            constructor() {
                console.log('ğŸ¸ MyGO!!!!! Roguelike TCG v2 å•Ÿå‹•');
                this.gameController = null;
                this.isInitialized = false;
            }
            
            async initialize() {
                if (this.isInitialized) return;
                
                try {
                    console.log('ğŸ”§ åˆå§‹åŒ–éŠæˆ²ç³»çµ±...');
                    
                    // ç­‰å¾… DOM åŠ è¼‰å®Œæˆ
                    if (document.readyState === 'loading') {
                        await new Promise(resolve => {
                            document.addEventListener('DOMContentLoaded', resolve);
                        });
                    }
                    
                    // å‰µå»ºéŠæˆ²æ§åˆ¶å™¨
                    this.gameController = new GameController();
                    
                    this.isInitialized = true;
                    console.log('âœ… æ‡‰ç”¨ç¨‹åºåˆå§‹åŒ–å®Œæˆ');
                    
                } catch (error) {
                    console.error('âŒ æ‡‰ç”¨ç¨‹åºåˆå§‹åŒ–å¤±æ•—:', error);
                    throw error;
                }
            }
            
            async startGame() {
                if (!this.isInitialized) {
                    console.error('âŒ æ‡‰ç”¨ç¨‹åºæœªåˆå§‹åŒ–');
                    return;
                }
                
                try {
                    console.log('ğŸš€ é–‹å§‹æ–°éŠæˆ²...');
                    this.gameController.startGame();
                } catch (error) {
                    console.error('âŒ é–‹å§‹éŠæˆ²æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
            
            runTests() {
                console.log('ğŸ§ª é‹è¡Œç³»çµ±æ¸¬è©¦...');
                
                try {
                    // æ¸¬è©¦å¡ç‰Œå‰µå»º
                    const testCards = ['president', 'kindness', 'shadow_devour'];
                    testCards.forEach(cardId => {
                        try {
                            const card = CardRegistry.create(cardId);
                            console.log(`âœ… ${cardId}: ${card.name} (${card.type}, ${card.attribute})`);
                        } catch (error) {
                            console.error(`âŒ ${cardId} å‰µå»ºå¤±æ•—:`, error);
                        }
                    });
                    
                    console.log('âœ… ç³»çµ±æ¸¬è©¦å®Œæˆï¼');
                    
                } catch (error) {
                    console.error('âŒ æ¸¬è©¦å¤±æ•—:', error);
                }
            }
        }

        // ===== ğŸš€ æ‡‰ç”¨ç¨‹åºå•Ÿå‹• =====
        const app = new MyGoTCGApplication();

        app.initialize().then(() => {
            console.log('ğŸ‰ MyGO!!!!! TCG æ‡‰ç”¨ç¨‹åºå°±ç·’');
            
            // é‹è¡Œæ¸¬è©¦
            app.runTests();
            
            // è‡ªå‹•é–‹å§‹éŠæˆ²
            app.startGame();
            
        }).catch(error => {
            console.error('ğŸ’¥ æ‡‰ç”¨ç¨‹åºå•Ÿå‹•å¤±æ•—:', error);
        });

        // å°‡æ‡‰ç”¨ç¨‹åºå¯¦ä¾‹æš´éœ²åˆ°å…¨å±€ï¼Œä¾¿æ–¼èª¿è©¦
        window.MyGoTCG = app;
        
        // èª¿è©¦åŠŸèƒ½
        window.gameDebug = {
            getState: () => app.gameController?.getGameState(),
            addCard: (cardId) => {
                if (app.gameController && CardRegistry.cards.has(cardId)) {
                    const card = CardRegistry.create(cardId);
                    app.gameController.gameState.player.hand.push(card);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`ğŸ”§ èª¿è©¦ï¼šæ·»åŠ äº† ${card.name}`);
                }
            },
            damageP: (amount) => {
                if (app.gameController) {
                    app.gameController.gameState.pitcher.current_hp -= amount;
                    app.gameController.gameState.pitcher.current_hp = Math.max(0, app.gameController.gameState.pitcher.current_hp);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`ğŸ”§ èª¿è©¦ï¼šå°æŠ•æ‰‹é€ æˆ ${amount} é»å‚·å®³`);
                }
            },
            heal: (amount) => {
                if (app.gameController) {
                    app.gameController.gameState.player.current_hp += amount;
                    app.gameController.gameState.player.current_hp = Math.min(app.gameController.gameState.player.max_hp, app.gameController.gameState.player.current_hp);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`ğŸ”§ èª¿è©¦ï¼šå›å¾© ${amount} é»ç”Ÿå‘½å€¼`);
                }
            }
        };

    </script>
</body>

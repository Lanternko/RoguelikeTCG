<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyGO!!!!! Roguelike TCG v2 - 完整版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'human-base': '#9F563A',
                        'human-dark': '#79432C',
                        'human-text': '#F3EAD3',
                        'yin-base': '#293047',
                        'yin-dark': '#1A2033',
                        'yin-text': '#D0D8E8',
                        'yang-base': '#FCFAF2',
                        'yang-dark': '#E0D8C0',
                        'yang-text': '#5D4037',
                        'heaven-base': '#4A90E2',
                        'heaven-dark': '#357ABD',
                        'heaven-text': '#F0F8FF',
                        'earth-base': '#8B4513',
                        'earth-dark': '#654321',
                        'earth-text': '#F5DEB3',
                        'legendary-ring': '#DAA520'
                    },
                    animation: {
                        'damage': 'damage 1.5s ease-out forwards',
                        'heal': 'heal 1.5s ease-out forwards',
                        'glow': 'glow 2s ease-in-out infinite alternate',
                        'shake': 'shake 0.5s ease-in-out',
                        'card-draw': 'cardDraw 0.8s ease-out forwards',
                        'pulse-glow': 'pulseGlow 2s ease-in-out infinite'
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; }
        
        @keyframes damage {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #EF4444; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(0.8); opacity: 0; }
        }
        
        @keyframes heal {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #10B981; }
            50% { transform: translateY(-20px) scale(1.1); opacity: 1; }
            100% { transform: translateY(-40px) scale(0.9); opacity: 0; }
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(218, 165, 32, 0.3); }
            to { box-shadow: 0 0 20px rgba(218, 165, 32, 0.7); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes cardDraw {
            0% { transform: translateY(100px) scale(0.5); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        @keyframes pulseGlow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .card-hover {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-hover:hover {
            transform: translateY(-8px) scale(1.05);
            z-index: 20;
        }
        
        .drop-zone {
            transition: all 0.3s ease;
            border: 2px dashed transparent;
        }
        .drop-zone.drag-over {
            border-color: #10B981;
            background-color: rgba(16, 185, 129, 0.1);
            transform: scale(1.02);
        }
        
        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 1.8rem;
            z-index: 1000;
            pointer-events: none;
        }
        
        .hp-bar-transition {
            transition: width 1s ease-out;
        }
        
        .card-zone-occupied {
            border-color: #10B981;
            border-style: solid;
        }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen">

    <!-- 遊戲標題與狀態 -->
    <header class="bg-slate-800 p-4 shadow-lg">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center gap-4">
                <h1 class="text-2xl font-bold bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent">
                    🎸 MyGO!!!!! Roguelike TCG v2
                </h1>
                <div class="text-sm text-gray-400">分層架構完整版</div>
            </div>
            
            <div class="flex items-center gap-4">
                <div class="text-center">
                    <div class="text-xs text-gray-400">回合</div>
                    <div id="turn-counter" class="text-xl font-bold text-yellow-400">1</div>
                </div>
                
                <div class="text-center">
                    <div class="text-xs text-gray-400">牌庫</div>
                    <div id="deck-count" class="text-lg font-bold text-blue-400">15</div>
                </div>
                
                <div class="text-center">
                    <div class="text-xs text-gray-400">棄牌</div>
                    <div id="discard-count" class="text-lg font-bold text-purple-400">0</div>
                </div>
                
                <button id="reset-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors">
                    🔄 重置
                </button>
            </div>
        </div>
    </header>

    <!-- 主遊戲區域 -->
    <main class="container mx-auto p-4">
        
        <!-- 遊戲狀態與階段指示器 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            
            <!-- 玩家狀態 -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-green-400 flex items-center gap-2">
                    🛡️ 玩家狀態
                    <div id="player-status-indicator" class="w-3 h-3 rounded-full bg-green-500 animate-pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>生命值</span>
                        <span id="player-hp" class="font-bold text-green-400">100/100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="player-hp-bar" class="bg-gradient-to-r from-green-500 to-green-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <div id="player-buffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>

            <!-- 階段指示器 -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-center">🎯 遊戲階段</h2>
                <div id="game-phase" class="bg-blue-600 text-center py-3 px-4 rounded-lg font-bold text-white">
                    抽牌階段
                </div>
                
                <div id="phase-description" class="text-center text-sm text-gray-400 mt-2">
                    準備開始新回合...
                </div>
            </div>

            <!-- 投手狀態 -->
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-red-400 flex items-center gap-2">
                    ⚔️ 投手狀態
                    <div id="pitcher-status-indicator" class="w-3 h-3 rounded-full bg-red-500 animate-pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>生命值</span>
                        <span id="pitcher-hp" class="font-bold text-red-400">150/150</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="pitcher-hp-bar" class="bg-gradient-to-r from-red-500 to-red-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <div class="flex justify-between text-sm">
                        <span>攻擊力</span>
                        <span id="pitcher-attack" class="font-bold text-orange-400">30</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>屬性</span>
                        <span id="pitcher-attribute" class="font-bold text-purple-400">天</span>
                    </div>
                    
                    <div id="pitcher-debuffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>
        </div>

        <!-- 戰鬥區域 -->
        <div class="bg-slate-800 p-6 rounded-xl mb-6">
            <h2 class="text-xl font-bold mb-6 text-center">⚔️ 戰鬥區域</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <!-- 打擊區 -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-red-300">🗡️ 打擊區</h3>
                    <div id="strike-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="strike_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">🗡️</div>
                            <div class="text-sm">拖拽打者卡到此處</div>
                        </div>
                    </div>
                </div>
                
                <!-- 輔助區 -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-blue-300">🛡️ 輔助區</h3>
                    <div id="support-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="support_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">🛡️</div>
                            <div class="text-sm">拖拽輔助卡到此處</div>
                        </div>
                    </div>
                </div>
                
                <!-- 法術區 -->
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-purple-300">✨ 法術區</h3>
                    <div id="spell-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="spell_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">✨</div>
                            <div class="text-sm">拖拽法術卡到此處</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 戰鬥按鈕區域 -->
            <div class="flex justify-center gap-4">
                <button id="attack-btn" class="px-8 py-4 bg-red-600 hover:bg-red-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    ⚔️ 攻擊！
                </button>
                <button id="end-turn-btn" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    🔄 結束回合
                </button>
            </div>
        </div>

        <!-- 手牌區域 -->
        <div class="bg-slate-800 p-4 rounded-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold">🎴 手牌</h2>
                <div class="text-sm text-gray-400">
                    <span id="hand-count">0</span>/7 張
                </div>
            </div>
            <div id="hand-cards" class="flex gap-3 overflow-x-auto pb-2 min-h-[140px]">
                <!-- 手牌將在這裡動態生成 -->
            </div>
        </div>

        <!-- 遊戲日誌 -->
        <div class="bg-slate-800 p-4 rounded-xl mt-6">
            <h2 class="text-lg font-bold mb-3 text-purple-400">📜 戰鬥日誌</h2>
            <div id="game-log" class="h-32 overflow-y-auto space-y-1 text-sm bg-slate-900 p-3 rounded">
                <div class="text-green-400">🚀 遊戲開始！歡迎來到 MyGO!!!!! Roguelike TCG v2</div>
            </div>
        </div>
    </main>

    <script>
        // ===== 📊 遊戲常數與平衡 =====
        const GAME_BALANCE = {
            PLAYER_INITIAL_HP: 100,
            PITCHER_INITIAL_HP: 150,
            HAND_SIZE_LIMIT: 7,
            STRIKE_ZONE_LIMIT: 1,
            SUPPORT_ZONE_LIMIT: 1,
            SPELL_ZONE_LIMIT: 1,
            PITCHER_BASE_FATIGUE_RATE: 0.05,
            
            // 效果數值
            KINDNESS_BOOST: 10,
            DEMOCRACY_OUT_REDUCTION: 5,
            PATIENCE_DAMAGE_REDUCTION: 10,
            UNITY_BOOST: 8,
            PITCHER_ATTACK_REDUCTION: 3,
            
            // 屬性相關
            ATTRIBUTE_TYPES: ['human', 'yin', 'yang', 'heaven', 'earth'],
            MIN_ATTRIBUTES_FOR_BONUS: 3
        };

        // ===== 🃏 卡牌平衡數據 =====
        const CARD_BALANCE = {
            // 人屬 - 普通
            PRESIDENT: { hp: 10, attack: 15, crit: 35 },
            KINDNESS: { hp: 12, attack: 8, crit: 70 },
            HERO: { hp: 10, attack: 25, crit: 50 },
            LOTTERY: { hp: 8 },
            STRONGMAN: { hp: 15, attack: 18, crit: 50 },
            DEMOCRACY: { hp: 10, attack: 5, crit: 75 },
            CULTURE: { hp: 12 },
            PATIENCE: { hp: 10 },
            UNITY: { hp: 11 },
            LEGACY: { hp: 9, attack: 5, crit: 50 },
            SIMPLE_FOLK: { hp: 13, attack: 27, crit: 50 },
            FLESH: { hp: 20, attack: 8, crit: 50 },
            INHERITANCE: { hp: 10, attack: 8, crit: 35 },
            
            // 人屬 - 稀有
            HELP_STREAM: { hp: 12, attack: 5, crit: 35 },
            BENEVOLENT_LEGACY: { hp: 10, attack: 35, crit: 35 },
            COMMUNISM: { hp: 10 },
            MULTICULTURE: { hp: 10, attack: 10, crit: 70 },
            PROSPERITY: { hp: 10, attack: 8, crit: 25 },
            
            // 人屬 - 傳說
            MASTER: { hp: 10, attack: 10, crit: 25 },
            HEAD_PAT: { hp: 15 },
            
            // 陰屬
            SHADOW_DEVOUR: { hp: 10, attack: 20, crit: 35 },
            LONE_SHADOW: { hp: 9 },
            EVIL_GENIUS: { hp: 14, attack: 15, crit: 35 },
            AMBUSH: { hp: 6, attack: 10, crit: 35 },
            TIME_STOP: { hp: 10 },
            
            // 陽屬
            WEAPON_MASTER: { hp: 8, attack: 8, crit: 70 },
            HOLY_LIGHT: { hp: 8 },
            LATE_GAME: { hp: 8, attack: 5, crit: 35 },
            YIN_YANG_HARMONY: { hp: 0, attack: 20, crit: 25 },
            RESURRECTION: { hp: 0, attack: 10, crit: 25 }
        };

        // ===== 🎮 事件系統 =====
        class EventBus {
            constructor() {
                this.events = {};
            }
            
            on(event, callback) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(callback);
            }
            
            emit(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(callback => callback(data));
                }
            }
            
            off(event, callback) {
                if (this.events[event]) {
                    this.events[event] = this.events[event].filter(cb => cb !== callback);
                }
            }
        }

        // ===== 🃏 卡牌註冊系統 =====
        class CardRegistry {
            static cards = new Map();
            static initialized = false;
            
            static initialize() {
                if (this.initialized) return;
                
                console.log('🃏 初始化卡牌註冊系統...');
                
                // 註冊所有卡牌
                this.registerAllCards();
                
                this.initialized = true;
                console.log(`✅ 成功註冊 ${this.cards.size} 張卡牌`);
            }
            
            static registerAllCards() {
                // 人屬 - 普通
                this.register('president', this.createPresidentCard);
                this.register('kindness', this.createKindnessCard);
                this.register('hero', this.createHeroCard);
                this.register('lottery', this.createLotteryCard);
                this.register('strongman', this.createStrongmanCard);
                this.register('democracy', this.createDemocracyCard);
                
                // 陰屬
                this.register('shadow_devour', this.createShadowDevourCard);
                this.register('lone_shadow', this.createLoneShadowCard);
                this.register('evil_genius', this.createEvilGeniusCard);
                
                // 陽屬
                this.register('weapon_master', this.createWeaponMasterCard);
                this.register('yinyang_harmony', this.createYinYangHarmonyCard);
                this.register('holy_light', this.createHolyLightCard);
            }
            
            static register(id, cardFactory) {
                this.cards.set(id, cardFactory);
            }
            
            static create(id) {
                if (!this.initialized) this.initialize();
                
                const cardFactory = this.cards.get(id);
                if (!cardFactory) {
                    throw new Error(`未找到卡牌: ${id}`);
                }
                
                const card = cardFactory();
                card.cardId = id;
                return card;
            }
            
            // ===== 🎴 卡牌工廠方法 =====
            
            static createPresidentCard() {
                const balance = CARD_BALANCE.PRESIDENT;
                return {
                    id: 'president',
                    name: '總統',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: '打擊：此回合中，牌組裡每有一張人屬性卡，攻擊力+1',
                    effects: {
                        on_strike: async function(gameState) {
                            let humanCards = 0;
                            
                            // 計算手牌中的人屬卡
                            gameState.player.hand.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            
                            // 計算棄牌堆中的人屬卡
                            gameState.player.discard_pile.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + humanCards;
                            
                            return {
                                success: true,
                                description: `人屬性卡數量: ${humanCards}，攻擊力+${humanCards}`
                            };
                        }
                    }
                };
            }
            
            static createKindnessCard() {
                const balance = CARD_BALANCE.KINDNESS;
                return {
                    id: 'kindness',
                    name: '慈愛',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: '輔助：此回合中，人屬性打者卡攻擊力+10',
                    effects: {
                        on_support: async function(gameState) {
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 3;
                            
                            return {
                                success: true,
                                description: '投手攻擊力-3'
                            };
                        }
                    }
                };
            }
            
            static createLoneShadowCard() {
                const balance = CARD_BALANCE.LONE_SHADOW;
                return {
                    id: 'lone_shadow',
                    name: '孤影',
                    type: 'spell',
                    attribute: 'yin',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp
                    },
                    description: '減投手5攻(本回合)。抽1張牌',
                    effects: {
                        on_play: async function(gameState) {
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 5;
                            
                            // 抽1張牌
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                            }
                            
                            return {
                                success: true,
                                description: '投手攻擊力-5，抽1張牌'
                            };
                        }
                    }
                };
            }
            
            static createEvilGeniusCard() {
                const balance = CARD_BALANCE.EVIL_GENIUS;
                return {
                    id: 'evil_genius',
                    name: '邪惡天才',
                    type: 'batter',
                    attribute: 'yin',
                    rarity: 'rare',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: '打擊：吸取投手5點攻擊力',
                    effects: {
                        on_strike: async function(gameState) {
                            // 減少投手攻擊力
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 5;
                            
                            // 增加自己攻擊力
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + 5;
                            
                            return {
                                success: true,
                                description: '吸取投手5點攻擊力'
                            };
                        }
                    }
                };
            }
            
            static createWeaponMasterCard() {
                const balance = CARD_BALANCE.WEAPON_MASTER;
                return {
                    id: 'weapon_master',
                    name: '武器大師',
                    type: 'batter',
                    attribute: 'yang',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: '輔助：手牌中每有一種不同屬性的卡，打者攻擊力+5',
                    effects: {
                        on_support: async function(gameState) {
                            const attributes = new Set();
                            gameState.player.hand.forEach(card => {
                                attributes.add(card.attribute);
                            });
                            
                            const boost = attributes.size * 5;
                            gameState.turnBuffs = gameState.turnBuffs || [];
                            gameState.turnBuffs.push({
                                type: 'batter_attack_boost',
                                value: boost,
                                source: this.name
                            });
                            
                            return {
                                success: true,
                                description: `手牌${attributes.size}種屬性，打者攻擊力+${boost}`
                            };
                        }
                    }
                };
            }
            
            static createYinYangHarmonyCard() {
                const balance = CARD_BALANCE.YIN_YANG_HARMONY;
                return {
                    id: 'yinyang_harmony',
                    name: '陰陽調和',
                    type: 'batter',
                    attribute: 'yang',
                    rarity: 'rare',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: '打擊：若輔助格為陰屬性，攻擊力翻倍',
                    effects: {
                        on_strike: async function(gameState) {
                            const supportCard = gameState.player.support_zone;
                            
                            if (supportCard && supportCard.attribute === 'yin') {
                                const currentAttack = this.stats.attack + (this.tempBonus?.attack || 0);
                                this.tempBonus = this.tempBonus || {};
                                this.tempBonus.attack = currentAttack;
                                
                                return {
                                    success: true,
                                    description: '輔助格為陰屬性，攻擊力翻倍！'
                                };
                            }
                            
                            return {
                                success: false,
                                reason: '輔助格不是陰屬性'
                            };
                        }
                    }
                };
            }
            
            static createHolyLightCard() {
                const balance = CARD_BALANCE.HOLY_LIGHT;
                return {
                    id: 'holy_light',
                    name: '聖光',
                    type: 'spell',
                    attribute: 'yang',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp
                    },
                    description: '選擇一張手牌，其攻擊力+8(本回合)。抽1張牌',
                    effects: {
                        on_play: async function(gameState) {
                            // 簡化實現：給第一張打者卡+8攻擊力
                            const batterCard = gameState.player.hand.find(card => card.type === 'batter');
                            if (batterCard) {
                                batterCard.tempBonus = batterCard.tempBonus || {};
                                batterCard.tempBonus.attack = (batterCard.tempBonus.attack || 0) + 8;
                            }
                            
                            // 抽1張牌
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                            }
                            
                            return {
                                success: true,
                                description: batterCard ? `${batterCard.name}攻擊力+8，抽1張牌` : '抽1張牌'
                            };
                        }
                    }
                };
            }
            
            static getStats() {
                const stats = {
                    total: this.cards.size,
                    byAttribute: {},
                    byType: {},
                    byRarity: {}
                };
                
                for (const [id, cardFactory] of this.cards.entries()) {
                    try {
                        const card = cardFactory();
                        stats.byAttribute[card.attribute] = (stats.byAttribute[card.attribute] || 0) + 1;
                        stats.byType[card.type] = (stats.byType[card.type] || 0) + 1;
                        stats.byRarity[card.rarity] = (stats.byRarity[card.rarity] || 0) + 1;
                    } catch (error) {
                        console.warn(`統計卡牌 ${id} 時出錯:`, error);
                    }
                }
                
                return stats;
            }
        }

        // ===== 🎮 遊戲狀態管理 =====
        class GameState {
            constructor() {
                this.player = {
                    current_hp: GAME_BALANCE.PLAYER_INITIAL_HP,
                    max_hp: GAME_BALANCE.PLAYER_INITIAL_HP,
                    deck: [],
                    hand: [],
                    discard_pile: [],
                    strike_zone: null,
                    support_zone: null,
                    spell_zone: null,
                    active_buffs: []
                };
                
                this.pitcher = {
                    current_hp: GAME_BALANCE.PITCHER_INITIAL_HP,
                    max_hp: GAME_BALANCE.PITCHER_INITIAL_HP,
                    base_attack: 30,
                    current_attack: 30,
                    attribute: 'heaven',
                    active_debuffs: []
                };
                
                this.gamePhase = 'DRAW_PHASE';
                this.turnCount = 1;
                this.turnBuffs = [];
                this.turnPlayedCards = [];
            }
        }

        // ===== ⚔️ 戰鬥系統 =====
        class CombatSystem {
            constructor(eventBus) {
                this.eventBus = eventBus || new EventBus();
            }

            calculateDamage(gameState) {
                console.log('⚔️ 開始傷害計算...');
                
                let totalAttack = 0;
                let totalCrit = 0;
                
                const strikeCard = gameState.player.strike_zone;
                const supportCard = gameState.player.support_zone;
                
                if (strikeCard) {
                    totalAttack += strikeCard.stats.attack;
                    totalCrit += strikeCard.stats.crit;
                    console.log(`🗡️ 打擊區: ${strikeCard.name} - 攻擊:${strikeCard.stats.attack} 暴擊:${strikeCard.stats.crit}`);
                }
                
                if (supportCard) {
                    totalAttack += supportCard.stats.attack;
                    totalCrit += supportCard.stats.crit;
                    console.log(`🛡️ 輔助區: ${supportCard.name} - 攻擊:${supportCard.stats.attack} 暴擊:${supportCard.stats.crit}`);
                }

                // 應用卡牌效果與Buff
                const modifiedStats = this.applyEffectsAndBuffs(gameState, totalAttack, totalCrit, strikeCard, supportCard);
                totalAttack = modifiedStats.attack;
                totalCrit = modifiedStats.crit;
                
                console.log(`💪 效果後數值 - 總攻擊:${totalAttack} 總暴擊:${totalCrit}`);

                // 計算最終傷害
                let finalDamage = totalAttack * (1 + totalCrit / 100);
                console.log(`🧮 核心公式: ${totalAttack} * (1 + ${totalCrit}/100) = ${finalDamage}`);

                // 應用屬性克制
                const playerMainAttr = this.getPlayerMainAttribute(gameState);
                const pitcherAttr = gameState.pitcher.attribute;
                
                if (this.isStrongAgainst(playerMainAttr, pitcherAttr)) {
                    finalDamage *= 1.2;
                    console.log(`⚡ 屬性克制: ${playerMainAttr} 克制 ${pitcherAttr}, 傷害 x1.2 = ${finalDamage}`);
                }

                finalDamage = Math.round(finalDamage);
                console.log(`🎯 最終傷害: ${finalDamage}`);

                return {
                    finalDamage,
                    breakdown: {
                        baseAttack: totalAttack,
                        baseCrit: totalCrit,
                        critMultiplier: (1 + totalCrit / 100),
                        attributeBonus: this.isStrongAgainst(playerMainAttr, pitcherAttr) ? 1.2 : 1.0,
                        playerAttribute: playerMainAttr,
                        pitcherAttribute: pitcherAttr
                    }
                };
            }

            applyEffectsAndBuffs(gameState, baseAttack, baseCrit, strikeCard, supportCard) {
                let totalAttack = baseAttack;
                let totalCrit = baseCrit;

                // 應用打擊區卡牌的臨時加成
                if (strikeCard && strikeCard.tempBonus) {
                    if (strikeCard.tempBonus.attack) {
                        totalAttack += strikeCard.tempBonus.attack;
                        console.log(`✨ ${strikeCard.name} 臨時攻擊力: +${strikeCard.tempBonus.attack}`);
                    }
                    if (strikeCard.tempBonus.crit) {
                        totalCrit += strikeCard.tempBonus.crit;
                        console.log(`✨ ${strikeCard.name} 臨時暴擊: +${strikeCard.tempBonus.crit}`);
                    }
                }

                // 應用輔助區卡牌的臨時加成
                if (supportCard && supportCard.tempBonus) {
                    if (supportCard.tempBonus.attack) {
                        totalAttack += supportCard.tempBonus.attack;
                        console.log(`✨ ${supportCard.name} 臨時攻擊力: +${supportCard.tempBonus.attack}`);
                    }
                    if (supportCard.tempBonus.crit) {
                        totalCrit += supportCard.tempBonus.crit;
                        console.log(`✨ ${supportCard.name} 臨時暴擊: +${supportCard.tempBonus.crit}`);
                    }
                }

                // 應用全局Buff
                gameState.player.active_buffs?.forEach(buff => {
                    if (buff.type === 'ATTACK_UP') {
                        totalAttack += buff.value;
                        console.log(`🔥 全局Buff: 攻擊力 +${buff.value}`);
                    }
                    if (buff.type === 'CRIT_UP') {
                        totalCrit += buff.value;
                        console.log(`⚡ 全局Buff: 暴擊 +${buff.value}`);
                    }
                });

                // 應用回合Buff
                gameState.turnBuffs?.forEach(buff => {
                    if (buff.type === 'human_batter_attack_boost' && strikeCard?.attribute === 'human') {
                        totalAttack += buff.value;
                        console.log(`💝 ${buff.source}: 人屬打者攻擊力 +${buff.value}`);
                    }
                    if (buff.type === 'batter_attack_boost' && strikeCard?.type === 'batter') {
                        totalAttack += buff.value;
                        console.log(`⚔️ ${buff.source}: 打者攻擊力 +${buff.value}`);
                    }
                });

                return { attack: totalAttack, crit: totalCrit };
            }

            isStrongAgainst(playerAttr, enemyAttr) {
                const advantages = {
                    'human': ['yin'],
                    'yin': ['yang'], 
                    'yang': ['heaven'],
                    'heaven': ['earth'],
                    'earth': ['human']
                };
                
                return advantages[playerAttr]?.includes(enemyAttr) || false;
            }

            getPlayerMainAttribute(gameState) {
                if (gameState.player.strike_zone) {
                    return gameState.player.strike_zone.attribute;
                }
                
                if (gameState.player.support_zone) {
                    return gameState.player.support_zone.attribute;
                }
                
                return 'human';
            }

            async executeCombat(gameState) {
                console.log('🎮 開始戰鬥階段...');
                
                if (!gameState.player.strike_zone) {
                    return { success: false, reason: '打擊區沒有卡牌' };
                }

                // 觸發打擊區卡牌的 on_strike 效果
                const strikeCard = gameState.player.strike_zone;
                if (strikeCard.effects?.on_strike) {
                    console.log(`🎯 觸發 ${strikeCard.name} 的打擊效果`);
                    const effectResult = await strikeCard.effects.on_strike.call(strikeCard, gameState);
                    if (effectResult.success) {
                        console.log(`✅ 打擊效果: ${effectResult.description}`);
                    }
                }

                // 觸發輔助區卡牌的 on_support 效果
                const supportCard = gameState.player.support_zone;
                if (supportCard?.effects?.on_support) {
                    console.log(`🛡️ 觸發 ${supportCard.name} 的輔助效果`);
                    const supportResult = await supportCard.effects.on_support.call(supportCard, gameState);
                    if (supportResult.success) {
                        console.log(`✅ 輔助效果: ${supportResult.description}`);
                    }
                }

                // 計算傷害
                const damageResult = this.calculateDamage(gameState);
                
                // 對投手造成傷害
                gameState.pitcher.current_hp -= damageResult.finalDamage;
                gameState.pitcher.current_hp = Math.max(0, gameState.pitcher.current_hp);
                
                // 發出事件
                this.eventBus.emit('damage_dealt', {
                    damage: damageResult.finalDamage,
                    breakdown: damageResult.breakdown,
                    pitcherHP: gameState.pitcher.current_hp,
                    pitcherMaxHP: gameState.pitcher.max_hp
                });

                // 玩家受到投手攻擊
                const pitcherDamage = this.calculatePitcherDamage(gameState);
                gameState.player.current_hp -= pitcherDamage;
                gameState.player.current_hp = Math.max(0, gameState.player.current_hp);

                console.log(`🎯 戰鬥結果: 對投手造成${damageResult.finalDamage}傷害, 受到${pitcherDamage}傷害`);

                return {
                    success: true,
                    playerDamageDealt: damageResult.finalDamage,
                    playerDamageReceived: pitcherDamage,
                    damageBreakdown: damageResult.breakdown
                };
            }

            calculatePitcherDamage(gameState) {
                let pitcherDamage = gameState.pitcher.current_attack;
                
                // 應用投手的臨時減益
                if (gameState.pitcher.tempDebuff?.attack) {
                    pitcherDamage += gameState.pitcher.tempDebuff.attack;
                    console.log(`🔻 投手攻擊力減益: ${gameState.pitcher.tempDebuff.attack}`);
                }

                // 應用屬性克制
                const playerAttr = this.getPlayerMainAttribute(gameState);
                const pitcherAttr = gameState.pitcher.attribute;
                
                if (this.isStrongAgainst(pitcherAttr, playerAttr)) {
                    pitcherDamage *= 0.8;
                    console.log(`🛡️ 玩家被克制，傷害減少20%: ${pitcherDamage}`);
                }

                return Math.round(pitcherDamage);
            }

            applyPitcherFatigue(gameState) {
                const fatigueRate = GAME_BALANCE.PITCHER_BASE_FATIGUE_RATE;
                
                gameState.pitcher.current_attack *= (1 - fatigueRate);
                gameState.pitcher.current_attack = Math.round(gameState.pitcher.current_attack);
                
                console.log(`😴 投手疲勞: 攻擊力降至 ${gameState.pitcher.current_attack} (疲勞率: ${fatigueRate * 100}%)`);
                
                this.eventBus.emit('pitcher_fatigue', {
                    newAttack: gameState.pitcher.current_attack,
                    fatigueRate: fatigueRate
                });
            }
        }

        // ===== 🎯 回合系統 =====
        class TurnSystem {
            constructor(eventBus) {
                this.eventBus = eventBus || new EventBus();
            }

            async processTurn(gameState) {
                console.log(`🔄 開始第 ${gameState.turnCount} 回合...`);
                
                try {
                    // 1. 回合開始
                    await this.startOfTurn(gameState);
                    
                    // 2. 抽牌階段
                    await this.drawPhase(gameState);
                    
                    // 3. 出牌階段
                    gameState.gamePhase = 'PLAY_PHASE';
                    this.eventBus.emit('turn_phase_changed', { phase: 'PLAY_PHASE' });
                    
                } catch (error) {
                    console.error('❌ 回合處理失敗:', error);
                    this.eventBus.emit('turn_error', { error: error.message });
                }
            }

            async startOfTurn(gameState) {
                console.log('🌅 回合開始階段...');
                
                // 處理Buff/Debuff的持續時間
                this.updateBuffDurations(gameState.player.active_buffs);
                this.updateBuffDurations(gameState.pitcher.active_debuffs);
                
                this.eventBus.emit('turn_start', { gameState });
            }

            async drawPhase(gameState) {
                console.log('🎴 抽牌階段...');
                
                const handSizeLimit = GAME_BALANCE.HAND_SIZE_LIMIT;
                const drawCount = handSizeLimit - gameState.player.hand.length;
                
                console.log(`📋 當前手牌: ${gameState.player.hand.length}, 需抽牌: ${drawCount}`);
                
                for (let i = 0; i < drawCount; i++) {
                    if (!this.drawSingleCard(gameState)) {
                        console.log('⚠️ 無法繼續抽牌');
                        break;
                    }
                }
                
                this.eventBus.emit('draw_phase_complete', { 
                    drawnCards: drawCount,
                    handSize: gameState.player.hand.length 
                });
            }

            drawSingleCard(gameState) {
                // 如果牌庫為空，重新洗牌
                if (gameState.player.deck.length === 0) {
                    if (gameState.player.discard_pile.length === 0) {
                        console.log('📚 牌庫和棄牌堆都是空的，無法抽牌');
                        return false;
                    }
                    
                    console.log('🔀 牌庫為空，重新洗牌...');
                    gameState.player.deck = [...gameState.player.discard_pile];
                    gameState.player.discard_pile = [];
                    this.shuffleDeck(gameState.player.deck);
                    
                    this.eventBus.emit('deck_shuffled', { deckSize: gameState.player.deck.length });
                }
                
                if (gameState.player.deck.length > 0) {
                    const card = gameState.player.deck.pop();
                    gameState.player.hand.push(card);
                    console.log(`🎴 抽到: ${card.name}`);
                    
                    this.eventBus.emit('card_drawn', { card });
                    return true;
                }
                
                return false;
            }

            async combatPhase(gameState, combatSystem) {
                console.log('⚔️ 戰鬥階段...');
                gameState.gamePhase = 'COMBAT_PHASE';
                
                const combatResult = await combatSystem.executeCombat(gameState);
                
                this.eventBus.emit('combat_complete', { result: combatResult });
                
                return combatResult;
            }

            async endOfTurn(gameState, combatSystem) {
                console.log('🌙 回合結束階段...');
                
                // 將場上卡牌移入棄牌堆
                this.moveCardsToDiscard(gameState);
                
                // 投手疲勞
                combatSystem.applyPitcherFatigue(gameState);
                
                // 檢查勝負
                const gameOver = this.checkGameEnd(gameState);
                
                // 清理臨時效果
                this.cleanupTurnBuffs(gameState);
                
                // 增加回合計數
                gameState.turnCount++;
                
                this.eventBus.emit('turn_end', { gameState, gameOver });
                
                return gameOver;
            }

            moveCardsToDiscard(gameState) {
                const zones = ['strike_zone', 'support_zone', 'spell_zone'];
                
                zones.forEach(zone => {
                    if (gameState.player[zone]) {
                        const card = gameState.player[zone];
                        gameState.player.discard_pile.push(card);
                        gameState.player[zone] = null;
                        console.log(`🗂️ ${card.name} 移入棄牌堆`);
                    }
                });
            }

            updateBuffDurations(buffs) {
                if (!Array.isArray(buffs)) return;
                
                for (let i = buffs.length - 1; i >= 0; i--) {
                    const buff = buffs[i];
                    if (buff.duration > 0) {
                        buff.duration--;
                        if (buff.duration === 0) {
                            console.log(`⏰ Buff過期: ${buff.type}`);
                            buffs.splice(i, 1);
                        }
                    }
                }
            }

            cleanupTurnBuffs(gameState) {
                gameState.turnBuffs = [];
                gameState.turnPlayedCards = [];
                
                // 清理卡牌的臨時加成
                [...gameState.player.hand, ...gameState.player.discard_pile].forEach(card => {
                    if (card.tempBonus) {
                        delete card.tempBonus;
                    }
                });
                
                // 清理投手的臨時減益
                if (gameState.pitcher.tempDebuff) {
                    delete gameState.pitcher.tempDebuff;
                }
            }

            checkGameEnd(gameState) {
                if (gameState.player.current_hp <= 0) {
                    return { gameOver: true, winner: 'pitcher', reason: '玩家血量歸零' };
                }
                
                if (gameState.pitcher.current_hp <= 0) {
                    return { gameOver: true, winner: 'player', reason: '投手血量歸零' };
                }
                
                return { gameOver: false };
            }

            shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }
        }

        // ===== 🎨 UI 管理系統 =====
        class UIManager {
            constructor() {
                this.elements = {};
                this.initializeElements();
            }
            
            initializeElements() {
                this.elements = {
                    // 狀態顯示
                    playerHp: document.getElementById('player-hp'),
                    playerHpBar: document.getElementById('player-hp-bar'),
                    pitcherHp: document.getElementById('pitcher-hp'),
                    pitcherHpBar: document.getElementById('pitcher-hp-bar'),
                    pitcherAttack: document.getElementById('pitcher-attack'),
                    pitcherAttribute: document.getElementById('pitcher-attribute'),
                    
                    // 計數器
                    turnCounter: document.getElementById('turn-counter'),
                    deckCount: document.getElementById('deck-count'),
                    discardCount: document.getElementById('discard-count'),
                    handCount: document.getElementById('hand-count'),
                    
                    // 區域
                    strikeZone: document.getElementById('strike-zone'),
                    supportZone: document.getElementById('support-zone'),
                    spellZone: document.getElementById('spell-zone'),
                    handCards: document.getElementById('hand-cards'),
                    
                    // 控制
                    gamePhase: document.getElementById('game-phase'),
                    phaseDescription: document.getElementById('phase-description'),
                    gameLog: document.getElementById('game-log'),
                    
                    // 按鈕
                    attackBtn: document.getElementById('attack-btn'),
                    endTurnBtn: document.getElementById('end-turn-btn'),
                    resetBtn: document.getElementById('reset-btn')
                };
                
                return Object.values(this.elements).every(el => el !== null);
            }
            
            static generateCardClasses(attribute, rarity) {
                const baseClasses = 'w-28 h-36 rounded-xl p-3 text-xs cursor-pointer card-hover flex flex-col justify-between';
                
                const attributeColors = {
                    human: { base: 'human-base', dark: 'human-dark', text: 'human-text' },
                    yin: { base: 'yin-base', dark: 'yin-dark', text: 'yin-text' },
                    yang: { base: 'yang-base', dark: 'yang-dark', text: 'yang-text' },
                    heaven: { base: 'heaven-base', dark: 'heaven-dark', text: 'heaven-text' },
                    earth: { base: 'earth-base', dark: 'earth-dark', text: 'earth-text' }
                };
                
                const rarityStyles = {
                    common: (colors) => `bg-${colors.base}`,
                    rare: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-lg`,
                    legendary: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-xl ring-2 ring-legendary-ring animate-glow`
                };
                
                const colors = attributeColors[attribute] || attributeColors.human;
                const backgroundStyle = rarityStyles[rarity](colors);
                
                return `${baseClasses} ${backgroundStyle} text-${colors.text}`;
            }

            static renderCard(cardData, index, showDetails = true) {
                const cardClasses = this.generateCardClasses(cardData.attribute, cardData.rarity);
                
                return `
                    <div class="${cardClasses} animate-card-draw" draggable="true" data-card-index="${index}" style="animation-delay: ${index * 0.1}s">
                        <div class="text-center mb-2">
                            <div class="font-bold text-sm mb-1">${cardData.name}</div>
                            <div class="text-[10px] opacity-80 bg-black/20 px-2 py-1 rounded">${cardData.attribute} • ${cardData.type}</div>
                        </div>
                        
                        ${showDetails ? `
                        <div class="flex-1 text-[10px] leading-tight opacity-90">
                            ${cardData.description}
                        </div>
                        ` : ''}
                        
                        <div class="flex justify-between text-[11px] font-bold mt-2 bg-black/20 p-1 rounded">
                            <span title="攻擊力">⚔️${cardData.stats.attack || 0}</span>
                            <span title="暴擊值">💎${cardData.stats.crit || 0}</span>
                        </div>
                    </div>
                `;
            }

            static showFloatingText(element, text, type = 'damage') {
                const floatingText = document.createElement('div');
                floatingText.className = `floating-text animate-${type}`;
                floatingText.textContent = text;
                
                const rect = element.getBoundingClientRect();
                floatingText.style.left = `${rect.left + rect.width / 2 - 20}px`;
                floatingText.style.top = `${rect.top}px`;
                
                document.body.appendChild(floatingText);
                
                setTimeout(() => {
                    if (document.body.contains(floatingText)) {
                        document.body.removeChild(floatingText);
                    }
                }, 1500);
            }

            addLogEntry(message, type = 'info') {
                const logContainer = this.elements.gameLog;
                const logEntry = document.createElement('div');
                
                const colors = {
                    info: 'text-gray-300',
                    success: 'text-green-400',
                    damage: 'text-red-400',
                    heal: 'text-green-400',
                    system: 'text-blue-400',
                    warning: 'text-yellow-400'
                };
                
                logEntry.className = colors[type] || colors.info;
                logEntry.innerHTML = `<span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            updatePhaseDisplay(phase) {
                const phaseData = {
                    'DRAW_PHASE': { name: '抽牌階段', description: '補充手牌至7張', color: 'bg-blue-600' },
                    'PLAY_PHASE': { name: '出牌階段', description: '拖拽卡牌到戰鬥區域', color: 'bg-green-600' },
                    'COMBAT_PHASE': { name: '戰鬥階段', description: '計算傷害並執行攻擊', color: 'bg-red-600' }
                };
                
                const data = phaseData[phase];
                if (data) {
                    this.elements.gamePhase.textContent = data.name;
                    this.elements.gamePhase.className = `text-center py-3 px-4 rounded-lg font-bold text-white ${data.color}`;
                    this.elements.phaseDescription.textContent = data.description;
                }
            }

            updateUI(gameState) {
                this.updateHandDisplay(gameState);
                this.updateBattleZones(gameState);
                this.updateStatusDisplay(gameState);
                this.updateCounters(gameState);
                this.updatePhaseDisplay(gameState.gamePhase);
            }
            
            updateHandDisplay(gameState) {
                if (!this.elements.handCards) return;
                
                this.elements.handCards.innerHTML = gameState.player.hand
                    .map((card, index) => UIManager.renderCard(card, index))
                    .join('');
                
                if (this.elements.handCount) {
                    this.elements.handCount.textContent = gameState.player.hand.length;
                }
                
                // 重新綁定拖拽事件
                this.bindCardDragEvents();
            }
            
            bindCardDragEvents() {
                const cards = document.querySelectorAll('[data-card-index]');
                cards.forEach(card => {
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', e.target.dataset.cardIndex);
                    });
                });
            }
            
            updateBattleZones(gameState) {
                const zones = [
                    { id: 'strike-zone', state: 'strike_zone', icon: '🗡️', name: '打擊' },
                    { id: 'support-zone', state: 'support_zone', icon: '🛡️', name: '輔助' },
                    { id: 'spell-zone', state: 'spell_zone', icon: '✨', name: '法術' }
                ];
                
                zones.forEach(({ id, state, icon, name }) => {
                    const zoneElement = document.getElementById(id);
                    if (!zoneElement) return;
                    
                    const card = gameState.player[state];
                    
                    if (card) {
                        zoneElement.innerHTML = UIManager.renderCard(card, -1, false);
                        zoneElement.classList.add('card-zone-occupied');
                    } else {
                        zoneElement.innerHTML = `
                            <div class="text-center text-gray-400">
                                <div class="text-3xl mb-2">${icon}</div>
                                <div class="text-sm">拖拽${name}卡到此處</div>
                            </div>
                        `;
                        zoneElement.classList.remove('card-zone-occupied');
                    }
                });
            }
            
            updateStatusDisplay(gameState) {
                // 更新玩家狀態
                if (this.elements.playerHp) {
                    this.elements.playerHp.textContent = 
                        `${gameState.player.current_hp}/${gameState.player.max_hp}`;
                }
                if (this.elements.playerHpBar) {
                    this.elements.playerHpBar.style.width = 
                        `${(gameState.player.current_hp / gameState.player.max_hp) * 100}%`;
                }
                
                // 更新投手狀態
                if (this.elements.pitcherHp) {
                    this.elements.pitcherHp.textContent = 
                        `${gameState.pitcher.current_hp}/${gameState.pitcher.max_hp}`;
                }
                if (this.elements.pitcherHpBar) {
                    this.elements.pitcherHpBar.style.width = 
                        `${(gameState.pitcher.current_hp / gameState.pitcher.max_hp) * 100}%`;
                }
                if (this.elements.pitcherAttack) {
                    this.elements.pitcherAttack.textContent = gameState.pitcher.current_attack;
                }
                if (this.elements.pitcherAttribute) {
                    this.elements.pitcherAttribute.textContent = gameState.pitcher.attribute;
                }
            }
            
            updateCounters(gameState) {
                if (this.elements.turnCounter) {
                    this.elements.turnCounter.textContent = gameState.turnCount;
                }
                if (this.elements.deckCount) {
                    this.elements.deckCount.textContent = gameState.player.deck.length;
                }
                if (this.elements.discardCount) {
                    this.elements.discardCount.textContent = gameState.player.discard_pile.length;
                }
            }
        }

        // ===== 🎮 遊戲控制器 =====
        class GameController {
            constructor() {
                console.log('🎮 初始化遊戲控制器...');
                
                this.eventBus = new EventBus();
                this.gameState = new GameState();
                this.combatSystem = new CombatSystem(this.eventBus);
                this.turnSystem = new TurnSystem(this.eventBus);
                this.uiManager = new UIManager();
                
                CardRegistry.initialize();
                this.setupEventListeners();
                this.isGameRunning = false;
                
                console.log('✅ 遊戲控制器初始化完成');
            }

            setupEventListeners() {
                // 攻擊按鈕
                if (this.uiManager.elements.attackBtn) {
                    this.uiManager.elements.attackBtn.addEventListener('click', () => {
                        this.executeAttack();
                    });
                }
                
                // 結束回合按鈕
                if (this.uiManager.elements.endTurnBtn) {
                    this.uiManager.elements.endTurnBtn.addEventListener('click', () => {
                        this.endTurn();
                    });
                }
                
                // 重置按鈕
                if (this.uiManager.elements.resetBtn) {
                    this.uiManager.elements.resetBtn.addEventListener('click', () => {
                        if (confirm('確定要重置遊戲嗎？')) {
                            this.resetGame();
                        }
                    });
                }
                
                // 設置拖放
                this.setupDragAndDrop();
                
                // 設置事件監聽
                this.eventBus.on('damage_dealt', (data) => {
                    this.uiManager.addLogEntry(`💥 造成傷害: ${data.damage}`, 'damage');
                    UIManager.showFloatingText(this.uiManager.elements.pitcherHpBar, `-${data.damage}`, 'damage');
                    this.uiManager.elements.pitcherHpBar.classList.add('animate-shake');
                    setTimeout(() => {
                        this.uiManager.elements.pitcherHpBar.classList.remove('animate-shake');
                    }, 500);
                });

                this.eventBus.on('turn_phase_changed', (data) => {
                    this.uiManager.updatePhaseDisplay(data.phase);
                });

                this.eventBus.on('card_drawn', (data) => {
                    this.uiManager.addLogEntry(`🎴 抽到: ${data.card.name}`, 'success');
                });
            }
            
            setupDragAndDrop() {
                const zones = ['strike-zone', 'support-zone', 'spell-zone'];
                
                zones.forEach(zoneId => {
                    const zone = document.getElementById(zoneId);
                    if (!zone) return;
                    
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        zone.classList.add('drag-over');
                    });

                    zone.addEventListener('dragleave', () => {
                        zone.classList.remove('drag-over');
                    });

                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.classList.remove('drag-over');
                        
                        const cardIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const targetZone = zone.dataset.zone || zoneId.replace('-', '_');
                        
                        this.playCard(cardIndex, targetZone);
                    });
                });
            }
            
            async playCard(cardIndex, targetZone) {
                const card = this.gameState.player.hand[cardIndex];
                if (!card) {
                    this.uiManager.addLogEntry('❌ 無效的卡牌索引', 'damage');
                    return;
                }

                // 檢查遊戲階段
                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    this.uiManager.addLogEntry('❌ 不在出牌階段！', 'damage');
                    return;
                }

                // 檢查區域是否已有卡牌
                if (this.gameState.player[targetZone]) {
                    this.uiManager.addLogEntry('❌ 該區域已有卡牌！', 'damage');
                    return;
                }

                // 檢查卡牌類型是否匹配
                const validPlacements = {
                    'strike_zone': ['batter'],
                    'support_zone': ['batter', 'support'],
                    'spell_zone': ['spell']
                };

                if (!validPlacements[targetZone].includes(card.type)) {
                    this.uiManager.addLogEntry('❌ 卡牌類型不匹配！', 'damage');
                    return;
                }

                // 放置卡牌
                this.gameState.player[targetZone] = card;
                this.gameState.player.hand.splice(cardIndex, 1);

                // 記錄本回合打出的卡牌
                this.gameState.turnPlayedCards.push(card);

                // 觸發打出時效果
                if (card.effects?.on_play) {
                    const result = await card.effects.on_play.call(card, this.gameState);
                    if (result.success) {
                        this.uiManager.addLogEntry(`✨ ${result.description}`, 'success');
                    }
                }

                const zoneNames = {
                    'strike_zone': '打擊區',
                    'support_zone': '輔助區', 
                    'spell_zone': '法術區'
                };

                this.uiManager.addLogEntry(`🎴 ${card.name} 放置到${zoneNames[targetZone]}`, 'success');
                this.uiManager.updateUI(this.gameState);
            }
            
            async executeAttack() {
                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    this.uiManager.addLogEntry('❌ 不在出牌階段！', 'damage');
                    return;
                }
                
                if (!this.gameState.player.strike_zone) {
                    this.uiManager.addLogEntry('❌ 請先放置打擊卡牌！', 'damage');
                    return;
                }
                
                // 切換到戰鬥階段
                this.gameState.gamePhase = 'COMBAT_PHASE';
                this.uiManager.updatePhaseDisplay(this.gameState.gamePhase);
                
                // 執行戰鬥
                this.uiManager.addLogEntry('⚔️ 戰鬥開始！', 'system');
                
                const combatResult = await this.turnSystem.combatPhase(this.gameState, this.combatSystem);
                
                // 檢查勝負
                if (this.gameState.pitcher.current_hp <= 0) {
                    this.uiManager.addLogEntry('🏆 勝利！投手被擊敗了！', 'success');
                    setTimeout(() => {
                        alert('🎉 恭喜勝利！\n\n在完整版本中，這裡將進入獎勵選擇階段。');
                    }, 1000);
                    this.uiManager.updateUI(this.gameState);
                    return;
                }
                
                // 投手反擊
                setTimeout(() => {
                    this.pitcherAttack();
                }, 1000);
                
                this.uiManager.updateUI(this.gameState);
            }
            
            pitcherAttack() {
                const pitcherDamage = this.combatSystem.calculatePitcherDamage(this.gameState);
                
                this.gameState.player.current_hp -= pitcherDamage;
                this.gameState.player.current_hp = Math.max(0, this.gameState.player.current_hp);
                
                this.uiManager.addLogEntry(`💢 投手反擊！受到 ${pitcherDamage} 點傷害！`, 'damage');
                UIManager.showFloatingText(this.uiManager.elements.playerHpBar, `-${pitcherDamage}`, 'damage');
                
                // 震動效果
                this.uiManager.elements.playerHpBar.classList.add('animate-shake');
                setTimeout(() => {
                    this.uiManager.elements.playerHpBar.classList.remove('animate-shake');
                }, 500);
                
                // 檢查玩家是否被擊敗
                if (this.gameState.player.current_hp <= 0) {
                    this.uiManager.addLogEntry('💀 失敗！你被擊敗了！', 'damage');
                    setTimeout(() => {
                        alert('💀 遊戲結束！\n\n點擊重置開始新遊戲。');
                    }, 1000);
                    this.uiManager.updateUI(this.gameState);
                    return;
                }
                
                this.uiManager.updateUI(this.gameState);
                
                // 自動結束回合
                setTimeout(() => {
                    this.endTurn();
                }, 1500);
            }
            
            async endTurn() {
                const gameOver = await this.turnSystem.endOfTurn(this.gameState, this.combatSystem);
                
                if (gameOver.gameOver) {
                    this.uiManager.addLogEntry(`🏆 遊戲結束: ${gameOver.winner} 獲勝 (${gameOver.reason})`, 'success');
                    return;
                }
                
                // 開始新回合
                setTimeout(() => {
                    this.turnSystem.processTurn(this.gameState);
                    this.uiManager.updateUI(this.gameState);
                }, 1000);
            }
            
            resetGame() {
                this.gameState = new GameState();
                this.uiManager.elements.gameLog.innerHTML = '';
                this.startGame();
                this.uiManager.addLogEntry('🔄 遊戲已重置', 'system');
            }
            
            startGame() {
                console.log('🚀 遊戲開始！');
                
                // 初始化測試牌組
                this.initializeDeck();
                
                // 開始第一回合
                this.turnSystem.processTurn(this.gameState);
                
                this.uiManager.addLogEntry('🚀 遊戲開始！歡迎來到 MyGO!!!!! Roguelike TCG v2', 'success');
                this.uiManager.addLogEntry('💡 提示：將卡牌拖拽到戰鬥區域，然後點擊攻擊！', 'system');
                
                this.uiManager.updateUI(this.gameState);
            }
            
            initializeDeck() {
                // 創建測試牌組
                const testDeckIds = [
                    'president', 'president', 'kindness', 'kindness', 
                    'hero', 'hero', 'hero', 'shadow_devour', 'yinyang_harmony',
                    'lottery', 'strongman', 'democracy', 'weapon_master', 'holy_light', 'evil_genius'
                ];

                // 轉換為完整卡牌對象
                this.gameState.player.deck = testDeckIds.map(id => CardRegistry.create(id));
                this.turnSystem.shuffleDeck(this.gameState.player.deck);
                
                console.log(`🎴 牌組初始化完成: ${this.gameState.player.deck.length} 張卡牌`);
            }
            
            getGameState() {
                return { ...this.gameState };
            }
        }

        // ===== 🚀 主應用程序 =====
        class MyGoTCGApplication {
            constructor() {
                console.log('🎸 MyGO!!!!! Roguelike TCG v2 啟動');
                this.gameController = null;
                this.isInitialized = false;
            }
            
            async initialize() {
                if (this.isInitialized) return;
                
                try {
                    console.log('🔧 初始化遊戲系統...');
                    
                    // 等待 DOM 加載完成
                    if (document.readyState === 'loading') {
                        await new Promise(resolve => {
                            document.addEventListener('DOMContentLoaded', resolve);
                        });
                    }
                    
                    // 創建遊戲控制器
                    this.gameController = new GameController();
                    
                    this.isInitialized = true;
                    console.log('✅ 應用程序初始化完成');
                    
                } catch (error) {
                    console.error('❌ 應用程序初始化失敗:', error);
                    throw error;
                }
            }
            
            async startGame() {
                if (!this.isInitialized) {
                    console.error('❌ 應用程序未初始化');
                    return;
                }
                
                try {
                    console.log('🚀 開始新遊戲...');
                    this.gameController.startGame();
                } catch (error) {
                    console.error('❌ 開始遊戲時發生錯誤:', error);
                }
            }
            
            runTests() {
                console.log('🧪 運行系統測試...');
                
                try {
                    // 測試卡牌創建
                    const testCards = ['president', 'kindness', 'shadow_devour'];
                    testCards.forEach(cardId => {
                        try {
                            const card = CardRegistry.create(cardId);
                            console.log(`✅ ${cardId}: ${card.name} (${card.type}, ${card.attribute})`);
                        } catch (error) {
                            console.error(`❌ ${cardId} 創建失敗:`, error);
                        }
                    });
                    
                    console.log('✅ 系統測試完成！');
                    
                } catch (error) {
                    console.error('❌ 測試失敗:', error);
                }
            }
        }

        // ===== 🚀 應用程序啟動 =====
        const app = new MyGoTCGApplication();

        app.initialize().then(() => {
            console.log('🎉 MyGO!!!!! TCG 應用程序就緒');
            
            // 運行測試
            app.runTests();
            
            // 自動開始遊戲
            app.startGame();
            
        }).catch(error => {
            console.error('💥 應用程序啟動失敗:', error);
        });

        // 將應用程序實例暴露到全局，便於調試
        window.MyGoTCG = app;
        
        // 調試功能
        window.gameDebug = {
            getState: () => app.gameController?.getGameState(),
            addCard: (cardId) => {
                if (app.gameController && CardRegistry.cards.has(cardId)) {
                    const card = CardRegistry.create(cardId);
                    app.gameController.gameState.player.hand.push(card);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`🔧 調試：添加了 ${card.name}`);
                }
            },
            damageP: (amount) => {
                if (app.gameController) {
                    app.gameController.gameState.pitcher.current_hp -= amount;
                    app.gameController.gameState.pitcher.current_hp = Math.max(0, app.gameController.gameState.pitcher.current_hp);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`🔧 調試：對投手造成 ${amount} 點傷害`);
                }
            },
            heal: (amount) => {
                if (app.gameController) {
                    app.gameController.gameState.player.current_hp += amount;
                    app.gameController.gameState.player.current_hp = Math.min(app.gameController.gameState.player.max_hp, app.gameController.gameState.player.current_hp);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`🔧 調試：回復 ${amount} 點生命值`);
                }
            }
        };

    </script>
</body>

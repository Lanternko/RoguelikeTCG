<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyGO!!!!! Roguelike TCG v2 - å„ªåŒ–ç‰ˆæœ¬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'human-base': '#9F563A',
                        'human-dark': '#79432C',
                        'human-text': '#F3EAD3',
                        'yin-base': '#293047',
                        'yin-dark': '#1A2033',
                        'yin-text': '#D0D8E8',
                        'yang-base': '#FCFAF2',
                        'yang-dark': '#E0D8C0',
                        'yang-text': '#5D4037',
                        'heaven-base': '#4A90E2',
                        'heaven-dark': '#357ABD',
                        'heaven-text': '#F0F8FF',
                        'earth-base': '#8B4513',
                        'earth-dark': '#654321',
                        'earth-text': '#F5DEB3',
                        'legendary-ring': '#DAA520'
                    },
                    animation: {
                        'damage': 'damage 1.5s ease-out forwards',
                        'heal': 'heal 1.5s ease-out forwards',
                        'glow': 'glow 2s ease-in-out infinite alternate',
                        'shake': 'shake 0.5s ease-in-out',
                        'card-draw': 'cardDraw 0.8s ease-out forwards',
                        'pulse-glow': 'pulseGlow 2s ease-in-out infinite',
                        'spell-shimmer': 'spellShimmer 2s ease-in-out infinite'
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; }
        
        @keyframes damage {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #EF4444; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(0.8); opacity: 0; }
        }
        
        @keyframes heal {
            0% { transform: translateY(0) scale(1); opacity: 1; color: #10B981; }
            50% { transform: translateY(-20px) scale(1.1); opacity: 1; }
            100% { transform: translateY(-40px) scale(0.9); opacity: 0; }
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(218, 165, 32, 0.3); }
            to { box-shadow: 0 0 20px rgba(218, 165, 32, 0.7); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes cardDraw {
            0% { transform: translateY(100px) scale(0.5); opacity: 0; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        @keyframes pulseGlow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @keyframes spellShimmer {
            0%, 100% { 
                box-shadow: 0 0 15px rgba(138, 43, 226, 0.4), 
                            inset 0 0 15px rgba(138, 43, 226, 0.1);
            }
            50% { 
                box-shadow: 0 0 25px rgba(138, 43, 226, 0.7), 
                            inset 0 0 25px rgba(138, 43, 226, 0.2);
            }
        }
        
        .card-hover {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-hover:hover {
            transform: translateY(-8px) scale(1.05);
            z-index: 20;
        }
        
        .drop-zone {
            transition: all 0.3s ease;
            border: 2px dashed transparent;
        }
        .drop-zone.drag-over {
            border-color: #10B981;
            background-color: rgba(16, 185, 129, 0.1);
            transform: scale(1.02);
        }
        
        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 1.8rem;
            z-index: 1000;
            pointer-events: none;
        }
        
        .hp-bar-transition {
            transition: width 1s ease-out;
        }
        
        .card-zone-occupied {
            border-color: #10B981;
            border-style: solid;
        }
        
        /* æ³•è¡“å¡ç‰¹æ•ˆ */
        .spell-card {
            position: relative;
            overflow: hidden;
        }
        
        .spell-card::before {
            content: 'âœ¨';
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 14px;
            z-index: 10;
            animation: spellShimmer 2s ease-in-out infinite;
        }
        
        .spell-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                transparent 30%, 
                rgba(138, 43, 226, 0.1) 50%, 
                transparent 70%);
            animation: spellShimmer 3s ease-in-out infinite;
            pointer-events: none;
        }
        
        /* æ­»è²å¡ç‰¹æ•ˆ */
        .deathrattle-card {
            position: relative;
        }
        
        .deathrattle-card::before {
            content: 'ğŸ’€';
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 12px;
            z-index: 10;
            opacity: 0.8;
        }
        
        /* æ‰‹ç‰Œå„ªåŒ– - æ¸›å°‘å‹•ç•«å»¶é² */
        .hand-card {
            animation-duration: 0.3s !important;
        }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen">

    <header class="bg-slate-800 p-4 shadow-lg">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center gap-4">
                <h1 class="text-2xl font-bold bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent">
                    ğŸ¸ MyGO!!!!! Roguelike TCG v2
                </h1>
                <div class="text-sm text-gray-400">å„ªåŒ–ç‰ˆæœ¬ - æ€§èƒ½æå‡</div>
            </div>
            
            <div class="flex items-center gap-4">
                <div class="text-center">
                    <div class="text-xs text-gray-400">å›åˆ</div>
                    <div id="turn-counter" class="text-xl font-bold text-yellow-400">1</div>
                </div>
                
                <div class="text-center">
                    <div class="text-xs text-gray-400">éšæ®µ</div>
                    <div id="pitcher-stage" class="text-lg font-bold text-red-400">ç¬¬ä¸€éšæ®µ</div>
                </div>
                
                <div class="text-center">
                    <div class="text-xs text-gray-400">ç‰Œåº«</div>
                    <div id="deck-count" class="text-lg font-bold text-blue-400">15</div>
                </div>
                
                <div class="text-center">
                    <div class="text-xs text-gray-400">æ£„ç‰Œ</div>
                    <div id="discard-count" class="text-lg font-bold text-purple-400">0</div>
                </div>
                
                <button id="reset-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors">
                    ğŸ”„ é‡ç½®
                </button>
            </div>
        </div>
    </header>

    <main class="container mx-auto p-4">
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-4">
            
            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-green-400 flex items-center gap-2">
                    ğŸ›¡ï¸ ç©å®¶ç‹€æ…‹
                    <div id="player-status-indicator" class="w-3 h-3 rounded-full bg-green-500 animate-pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>ç”Ÿå‘½å€¼</span>
                        <span id="player-hp" class="font-bold text-green-400">100/100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="player-hp-bar" class="bg-gradient-to-r from-green-500 to-green-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <div id="player-buffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>

            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-center">ğŸ¯ éŠæˆ²éšæ®µ</h2>
                <div id="game-phase" class="bg-blue-600 text-center py-3 px-4 rounded-lg font-bold text-white">
                    æŠ½ç‰Œéšæ®µ
                </div>
                
                <div id="phase-description" class="text-center text-sm text-gray-400 mt-2">
                    æº–å‚™é–‹å§‹æ–°å›åˆ...
                </div>
            </div>

            <div class="bg-slate-800 p-4 rounded-xl">
                <h2 class="text-lg font-bold mb-3 text-red-400 flex items-center gap-2">
                    âš”ï¸ æŠ•æ‰‹ç‹€æ…‹
                    <div id="pitcher-status-indicator" class="w-3 h-3 rounded-full bg-red-500 animate-pulse-glow"></div>
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between items-center">
                        <span>ç”Ÿå‘½å€¼</span>
                        <span id="pitcher-hp" class="font-bold text-red-400">150/150</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                        <div id="pitcher-hp-bar" class="bg-gradient-to-r from-red-500 to-red-400 h-3 rounded-full hp-bar-transition" style="width: 100%"></div>
                    </div>
                    
                    <div class="flex justify-between text-sm">
                        <span>æ”»æ“ŠåŠ›</span>
                        <span id="pitcher-attack" class="font-bold text-orange-400">30</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span>å±¬æ€§</span>
                        <span id="pitcher-attribute" class="font-bold text-purple-400">å¤©</span>
                    </div>
                    
                    <div id="pitcher-debuffs" class="flex gap-2 flex-wrap"></div>
                </div>
            </div>
        </div>

        <div class="bg-slate-800 p-6 rounded-xl mb-6">
            <h2 class="text-xl font-bold mb-6 text-center">âš”ï¸ æˆ°é¬¥å€åŸŸ</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-red-300">ğŸ—¡ï¸ æ‰“æ“Šå€</h3>
                    <div id="strike-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="strike_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">ğŸ—¡ï¸</div>
                            <div class="text-sm">æ‹–æ‹½æ‰“è€…å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
                
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-blue-300">ğŸ›¡ï¸ è¼”åŠ©å€</h3>
                    <div id="support-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="support_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">ğŸ›¡ï¸</div>
                            <div class="text-sm">æ‹–æ‹½è¼”åŠ©å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
                
                <div class="text-center">
                    <h3 class="text-sm font-bold mb-2 text-purple-300">âœ¨ æ³•è¡“å€</h3>
                    <div id="spell-zone" class="drop-zone bg-slate-700 border-2 border-dashed border-gray-600 rounded-xl p-4 h-40 flex items-center justify-center min-h-[160px]" data-zone="spell_zone">
                        <div class="text-center text-gray-400">
                            <div class="text-3xl mb-2">âœ¨</div>
                            <div class="text-sm">æ‹–æ‹½æ³•è¡“å¡åˆ°æ­¤è™•</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex justify-center gap-4">
                <button id="attack-btn" class="px-8 py-4 bg-red-600 hover:bg-red-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    âš”ï¸ æ”»æ“Šï¼
                </button>
                <button id="end-turn-btn" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-xl font-bold text-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    ğŸ”„ çµæŸå›åˆ
                </button>
            </div>
        </div>

        <div class="bg-slate-800 p-4 rounded-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold">ğŸ´ æ‰‹ç‰Œ</h2>
                <div class="text-sm text-gray-400">
                    <span id="hand-count">0</span>/7 å¼µ
                </div>
            </div>
            <!-- æ‰‹ç‰Œå€åŸŸçš„é«˜åº¦ -->
            <div id="hand-cards" class="flex gap-3 overflow-x-auto pb-2 min-h-[180px]">
                </div>
        </div>

        <div class="bg-slate-800 p-4 rounded-xl mt-6">
            <h2 class="text-lg font-bold mb-3 text-purple-400">ğŸ“œ æˆ°é¬¥æ—¥èªŒ</h2>
            <div id="game-log" class="h-32 overflow-y-auto space-y-1 text-sm bg-slate-900 p-3 rounded">
                <div class="text-green-400">ğŸš€ éŠæˆ²é–‹å§‹ï¼æ­¡è¿ä¾†åˆ° MyGO!!!!! Roguelike TCG v2</div>
            </div>
        </div>
    </main>

    <script>
        // ===== ğŸ“Š éŠæˆ²å¸¸æ•¸èˆ‡å¹³è¡¡ =====
        const GAME_BALANCE = {
            PLAYER_INITIAL_HP: 100,
            PITCHER_INITIAL_HP: 150,
            PITCHER_STAGE2_HP: 200,  // æ–°å¢ï¼šç¬¬äºŒéšæ®µè¡€é‡
            PITCHER_STAGE2_ATTACK: 45, // æ–°å¢ï¼šç¬¬äºŒéšæ®µæ”»æ“ŠåŠ›
            HAND_SIZE_LIMIT: 7,
            STRIKE_ZONE_LIMIT: 1,
            SUPPORT_ZONE_LIMIT: 1,
            SPELL_ZONE_LIMIT: 1,
            PITCHER_BASE_FATIGUE_RATE: 0.05,
            
            // æ•ˆæœæ•¸å€¼
            KINDNESS_BOOST: 10,
            DEMOCRACY_OUT_REDUCTION: 5,
            PATIENCE_DAMAGE_REDUCTION: 10,
            UNITY_BOOST: 8,
            PITCHER_ATTACK_REDUCTION: 3,
            
            // å±¬æ€§ç›¸é—œ
            ATTRIBUTE_TYPES: ['human', 'yin', 'yang', 'heaven', 'earth'],
            MIN_ATTRIBUTES_FOR_BONUS: 3
        };

        // ===== ğŸƒ å¡ç‰Œå¹³è¡¡æ•¸æ“š =====
        const CARD_BALANCE = {
            // äººå±¬ - æ™®é€š
            PRESIDENT: { hp: 10, attack: 15, crit: 35 },
            KINDNESS: { hp: 12, attack: 8, crit: 70 },
            HERO: { hp: 10, attack: 25, crit: 50 },
            LOTTERY: { hp: 8 },
            STRONGMAN: { hp: 15, attack: 18, crit: 50 },
            DEMOCRACY: { hp: 10, attack: 5, crit: 75 },
            CULTURE: { hp: 12 },
            PATIENCE: { hp: 10 },
            UNITY: { hp: 11 },
            LEGACY: { hp: 9, attack: 5, crit: 50 },
            SIMPLE_FOLK: { hp: 13, attack: 27, crit: 50 },
            FLESH: { hp: 20, attack: 8, crit: 50 },
            INHERITANCE: { hp: 10, attack: 8, crit: 35 },
            
            // äººå±¬ - ç¨€æœ‰
            HELP_STREAM: { hp: 12, attack: 5, crit: 35 },
            BENEVOLENT_LEGACY: { hp: 10, attack: 35, crit: 35 },
            COMMUNISM: { hp: 10 },
            MULTICULTURE: { hp: 10, attack: 10, crit: 70 },
            PROSPERITY: { hp: 10, attack: 8, crit: 25 },
            
            // äººå±¬ - å‚³èªª
            MASTER: { hp: 10, attack: 10, crit: 25 },
            HEAD_PAT: { hp: 15 },
            
            // é™°å±¬
            SHADOW_DEVOUR: { hp: 10, attack: 20, crit: 35 },
            LONE_SHADOW: { hp: 9 },
            EVIL_GENIUS: { hp: 14, attack: 15, crit: 35 },
            AMBUSH: { hp: 6, attack: 10, crit: 35 },
            TIME_STOP: { hp: 10 },
            
            // é™½å±¬
            WEAPON_MASTER: { hp: 8, attack: 8, crit: 70 },
            HOLY_LIGHT: { hp: 8 },
            LATE_GAME: { hp: 8, attack: 5, crit: 35 },
            YIN_YANG_HARMONY: { hp: 0, attack: 20, crit: 25 },
            RESURRECTION: { hp: 0, attack: 10, crit: 25 }
        };

        // ===== ğŸ® äº‹ä»¶ç³»çµ± =====
        class EventBus {
            constructor() {
                this.events = {};
            }
            
            on(event, callback) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(callback);
            }
            
            emit(event, data) {
                if (this.events[event]) {
                    this.events[event].forEach(callback => callback(data));
                }
            }
            
            off(event, callback) {
                if (this.events[event]) {
                    this.events[event] = this.events[event].filter(cb => cb !== callback);
                }
            }
        }

        // ===== ğŸƒ å¡ç‰Œè¨»å†Šç³»çµ± =====
        class CardRegistry {
            static cards = new Map();
            static initialized = false;
            
            static initialize() {
                if (this.initialized) return;
                
                console.log('ğŸƒ åˆå§‹åŒ–å¡ç‰Œè¨»å†Šç³»çµ±...');
                
                // è¨»å†Šæ‰€æœ‰å¡ç‰Œ
                this.registerAllCards();
                
                this.initialized = true;
                console.log(`âœ… æˆåŠŸè¨»å†Š ${this.cards.size} å¼µå¡ç‰Œ`);
            }
            
            static registerAllCards() {
                // äººå±¬ - æ™®é€š 
                this.register('president', this.createPresidentCard);
                this.register('kindness', this.createKindnessCard);
                this.register('hero', this.createHeroCard);
                this.register('lottery', this.createLotteryCard);
                this.register('strongman', this.createStrongmanCard);
                this.register('democracy', this.createDemocracyCard);
                this.register('culture', this.createCultureCard);
                this.register('patience', this.createPatienceCard);
                this.register('unity', this.createUnityCard);
                this.register('legacy', this.createLegacyCard);
                this.register('simple_folk', this.createSimpleFolkCard);
                this.register('flesh', this.createFleshCard);
                this.register('inheritance', this.createInheritanceCard);
                
                // äººå±¬ - ç¨€æœ‰ 
                this.register('help_stream', this.createHelpStreamCard);
                this.register('benevolent_legacy', this.createBenevolentLegacyCard);
                this.register('communism', this.createCommunismCard);
                this.register('multiculture', this.createMulticultureCard);
                this.register('prosperity', this.createProsperityCard);
                
                // äººå±¬ - å‚³èªª 
                this.register('master', this.createMasterCard);
                this.register('head_pat', this.createHeadPatCard);
                
                // é™°å±¬ 
                this.register('shadow_devour', this.createShadowDevourCard);
                this.register('lone_shadow', this.createLoneShadowCard);
                this.register('evil_genius', this.createEvilGeniusCard);
                this.register('ambush', this.createAmbushCard);
                this.register('time_stop', this.createTimeStopCard);
                
                // é™½å±¬ 
                this.register('weapon_master', this.createWeaponMasterCard);
                this.register('yinyang_harmony', this.createYinYangHarmonyCard);
                this.register('holy_light', this.createHolyLightCard);
                this.register('late_game', this.createLateGameCard);
                this.register('resurrection', this.createResurrectionCard);
            }
            
            static register(id, cardFactory) {
                this.cards.set(id, cardFactory);
            }
            
            static create(id) {
                if (!this.initialized) this.initialize();
                
                const cardFactory = this.cards.get(id);
                if (!cardFactory) {
                    throw new Error(`æœªæ‰¾åˆ°å¡ç‰Œ: ${id}`);
                }
                
                const card = cardFactory();
                card.cardId = id;
                return card;
            }
            
            // ===== ğŸ´ å¡ç‰Œå·¥å» æ–¹æ³• =====
            
            static createPresidentCard() {
                const balance = CARD_BALANCE.PRESIDENT;
                return {
                    id: 'president',
                    name: 'ç¸½çµ±',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'æ‰“æ“Šï¼šæ­¤å›åˆä¸­ï¼Œç‰Œçµ„è£¡æ¯æœ‰ä¸€å¼µäººå±¬æ€§å¡ï¼Œæ”»æ“ŠåŠ›+1',
                    effects: {
                        on_strike: async function(gameState) {
                            let humanCards = 0;
                            
                            gameState.player.hand.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            
                            gameState.player.discard_pile.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + humanCards;
                            
                            return {
                                success: true,
                                description: `äººå±¬æ€§å¡æ•¸é‡: ${humanCards}ï¼Œæ”»æ“ŠåŠ›+${humanCards}`
                            };
                        }
                    }
                };
            }
            
            static createKindnessCard() {
                const balance = CARD_BALANCE.KINDNESS;
                return {
                    id: 'kindness',
                    name: 'æ…ˆæ„›',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'è¼”åŠ©ï¼šæ­¤å›åˆä¸­ï¼Œäººå±¬æ€§æ‰“è€…å¡æ”»æ“ŠåŠ›+10',
                    effects: {
                        on_support: async function(gameState) {
                            gameState.turnBuffs = gameState.turnBuffs || [];
                            gameState.turnBuffs.push({
                                type: 'human_batter_attack_boost',
                                value: 10,
                                source: this.name
                            });
                            
                            return {
                                success: true,
                                description: 'äººå±¬æ€§æ‰“è€…å¡æ”»æ“ŠåŠ›+10'
                            };
                        }
                    }
                };
            }

            static createHeroCard() {
                const balance = CARD_BALANCE.HERO;
                return {
                    id: 'hero',
                    name: 'è‹±é›„',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'åŸºç¤æ‰“è€…å¡ï¼Œç„¡ç‰¹æ®Šæ•ˆæœ',
                    effects: {}
                };
            }

            static createLotteryCard() {
                const balance = CARD_BALANCE.LOTTERY;
                return {
                    id: 'lottery',
                    name: 'å¤§æ¨‚é€',
                    type: 'spell',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp
                    },
                    description: 'æŠ½1å¼µäººå±¬æ€§æ‰“è€…å¡',
                    effects: {
                        on_play: async function(gameState) {
                            const humanBatters = gameState.player.deck.filter(
                                card => card.attribute === 'human' && card.type === 'batter'
                            );
                            
                            if (humanBatters.length > 0) {
                                const randomCard = humanBatters[Math.floor(Math.random() * humanBatters.length)];
                                gameState.player.deck = gameState.player.deck.filter(c => c !== randomCard);
                                gameState.player.hand.push(randomCard);
                                
                                return {
                                    success: true,
                                    description: `æŠ½åˆ°äº† ${randomCard.name}`
                                };
                            }
                            
                            return {
                                success: false,
                                reason: 'ç‰Œåº«ä¸­æ²’æœ‰äººå±¬æ€§æ‰“è€…å¡'
                            };
                        }
                    }
                };
            }

            static createStrongmanCard() {
                const balance = CARD_BALANCE.STRONGMAN;
                return {
                    id: 'strongman',
                    name: 'çŒ›ç”·',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'é«˜è¡€é‡çš„å¼·åŠ›æ‰“è€…',
                    effects: {}
                };
            }

            static createDemocracyCard() {
                const balance = CARD_BALANCE.DEMOCRACY;
                return {
                    id: 'democracy',
                    name: 'æ°‘ä¸»',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'è¼”åŠ©ï¼šæ­¤å›åˆä¸­ï¼Œé™ä½5%å‡ºå±€æ©Ÿç‡',
                    effects: {
                        on_support: async function(gameState) {
                            gameState.turnBuffs = gameState.turnBuffs || [];
                            gameState.turnBuffs.push({
                                type: 'reduce_out_rate',
                                value: 5,
                                source: this.name
                            });
                            
                            return {
                                success: true,
                                description: 'é™ä½5%å‡ºå±€æ©Ÿç‡'
                            };
                        }
                    }
                };
            }

            static createCultureCard() {
                const balance = CARD_BALANCE.CULTURE;
                return {
                    id: 'culture',
                    name: 'æ–‡åŒ–è„ˆçµ¡',
                    type: 'spell',
                    attribute: 'human',
                    rarity: 'common',
                    stats: { hp_bonus: balance.hp },
                    description: 'æŠ½1å¼µä»»æ„å¡ç‰Œ',
                    effects: {
                        on_play: async function(gameState) {
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                                return { success: true, description: `æŠ½åˆ°äº† ${drawnCard.name}` };
                            }
                            return { success: false, reason: 'ç‰Œåº«ç‚ºç©º' };
                        }
                    }
                };
            }

            static createPatienceCard() {
                const balance = CARD_BALANCE.PATIENCE;
                return {
                    id: 'patience',
                    name: 'å¿è€',
                    type: 'spell',
                    attribute: 'human',
                    rarity: 'common',
                    stats: { hp_bonus: balance.hp },
                    description: 'æœ¬å›åˆæ¸›å°‘10é»æ‰€å—å‚·å®³',
                    effects: {
                        on_play: async function(gameState) {
                            gameState.turnBuffs = gameState.turnBuffs || [];
                            gameState.turnBuffs.push({
                                type: 'damage_reduction',
                                value: 10,
                                source: this.name
                            });
                            return { success: true, description: 'æœ¬å›åˆæ¸›å°‘10é»æ‰€å—å‚·å®³' };
                        }
                    }
                };
            }

            static createUnityCard() {
                const balance = CARD_BALANCE.UNITY;
                return {
                    id: 'unity',
                    name: 'åœ˜çµ',
                    type: 'spell',
                    attribute: 'human',
                    rarity: 'common',
                    stats: { hp_bonus: balance.hp },
                    description: 'æ­¤å›åˆä¸­ï¼Œä½ æ‰€æœ‰çš„äººå±¬æ€§æ‰“è€…å¡æ”»æ“ŠåŠ›+8',
                    effects: {
                        on_play: async function(gameState) {
                            gameState.turnBuffs = gameState.turnBuffs || [];
                            gameState.turnBuffs.push({
                                type: 'human_batter_attack_boost',
                                value: 8,
                                source: this.name
                            });
                            return { success: true, description: 'äººå±¬æ€§æ‰“è€…å¡æ”»æ“ŠåŠ›+8' };
                        }
                    }
                };
            }

            static createLegacyCard() {
                const balance = CARD_BALANCE.LEGACY;
                return {
                    id: 'legacy',
                    name: 'éºç”¢',
                    type: 'deathrattle',
                    attribute: 'human',
                    rarity: 'common',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'æ­»è²ï¼šæŠ½1å¼µå¡ç‰Œ',
                    effects: {
                        on_deathrattle: async function(gameState) {
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                                return { success: true, description: `æŠ½åˆ°äº† ${drawnCard.name}` };
                            }
                            return { success: false, reason: 'ç‰Œåº«ç‚ºç©º' };
                        }
                    }
                };
            }

            static createSimpleFolkCard() {
                const balance = CARD_BALANCE.SIMPLE_FOLK;
                return {
                    id: 'simple_folk',
                    name: 'æ°‘é¢¨æ·³æ¨¸',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'é«˜æ”»æ“ŠåŠ›çš„åŸºç¤æ‰“è€…',
                    effects: {}
                };
            }

            static createFleshCard() {
                const balance = CARD_BALANCE.FLESH;
                return {
                    id: 'flesh',
                    name: 'è‚‰å¡Š',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'common',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'é«˜è¡€é‡çš„è‚‰ç›¾æ‰“è€…',
                    effects: {}
                };
            }

            static createInheritanceCard() {
                const balance = CARD_BALANCE.INHERITANCE;
                return {
                    id: 'inheritance',
                    name: 'å‚³æ‰¿',
                    type: 'deathrattle',
                    attribute: 'human',
                    rarity: 'common',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'æ­»è²ï¼šæŠ½1å¼µäººå±¬æ€§å¡ç‰Œã€‚ä¸‹ä¸€å›åˆï¼Œä½ æ‰“å‡ºçš„äººå±¬æ€§æ‰“è€…å¡æ”»æ“ŠåŠ›+10',
                    effects: {
                        on_deathrattle: async function(gameState) {
                            const humanCards = gameState.player.deck.filter(card => card.attribute === 'human');
                            if (humanCards.length > 0) {
                                const randomCard = humanCards[Math.floor(Math.random() * humanCards.length)];
                                gameState.player.deck = gameState.player.deck.filter(c => c !== randomCard);
                                gameState.player.hand.push(randomCard);
                                
                                gameState.player.active_buffs.push({
                                    type: 'human_batter_attack_boost_next_turn',
                                    value: 10,
                                    duration: 1
                                });
                                
                                return { success: true, description: `æŠ½åˆ°äº† ${randomCard.name}ï¼Œä¸‹å›åˆäººå±¬æ‰“è€…+10æ”»æ“Š` };
                            }
                            return { success: false, reason: 'ç‰Œåº«ä¸­æ²’æœ‰äººå±¬æ€§å¡' };
                        }
                    }
                };
            }

            // ç¨€æœ‰å¡ç‰Œ
            static createHelpStreamCard() {
                const balance = CARD_BALANCE.HELP_STREAM;
                return {
                    id: 'help_stream',
                    name: 'å¹«æˆ‘é–‹ç›´æ’­',
                    type: 'deathrattle',
                    attribute: 'human',
                    rarity: 'rare',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'æ­»è²ï¼šä½ çš„äººå±¬æ€§æ‰“è€…å¡+5æ”»æ“ŠåŠ›',
                    effects: {
                        on_deathrattle: async function(gameState) {
                            let boostedCount = 0;
                            [...gameState.player.hand, ...gameState.player.deck, ...gameState.player.discard_pile].forEach(card => {
                                if (card.attribute === 'human' && card.type === 'batter') {
                                    card.permanentBonus = card.permanentBonus || {};
                                    card.permanentBonus.attack = (card.permanentBonus.attack || 0) + 5;
                                    boostedCount++;
                                }
                            });
                            return { success: true, description: `${boostedCount}å¼µäººå±¬æ‰“è€…å¡æ°¸ä¹…+5æ”»æ“ŠåŠ›` };
                        }
                    }
                };
            }

            static createBenevolentLegacyCard() {
                const balance = CARD_BALANCE.BENEVOLENT_LEGACY;
                return {
                    id: 'benevolent_legacy',
                    name: 'ä»é“å‚³æ‰¿',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'rare',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'æ‰“æ“Šï¼šè‹¥å ´ä¸Šæœ‰é™°æˆ–é™½å±¬æ€§å¡ï¼Œæ”»æ“ŠåŠ›+20ï¼›è‹¥å ´ä¸Šæœ‰å¤©æˆ–åœ°å±¬æ€§å¡ï¼Œæ£„1å¼µç‰ŒæŠ½2å¼µã€‚è¼”åŠ©ï¼šæŠ½1å¼µäººå±¬æ€§å¡',
                    effects: {
                        on_strike: async function(gameState) {
                            const fieldCards = [gameState.player.strike_zone, gameState.player.support_zone, gameState.player.spell_zone].filter(Boolean);
                            const hasYinYang = fieldCards.some(card => card && (card.attribute === 'yin' || card.attribute === 'yang'));
                            
                            if (hasYinYang) {
                                this.tempBonus = this.tempBonus || {};
                                this.tempBonus.attack = (this.tempBonus.attack || 0) + 20;
                                return { success: true, description: 'å ´ä¸Šæœ‰é™°/é™½å±¬æ€§ï¼Œæ”»æ“ŠåŠ›+20' };
                            }
                            return { success: false, reason: 'å ´ä¸Šæ²’æœ‰é™°/é™½å±¬æ€§å¡' };
                        },
                        on_support: async function(gameState) {
                            const humanCards = gameState.player.deck.filter(card => card.attribute === 'human');
                            if (humanCards.length > 0) {
                                const randomCard = humanCards[Math.floor(Math.random() * humanCards.length)];
                                gameState.player.deck = gameState.player.deck.filter(c => c !== randomCard);
                                gameState.player.hand.push(randomCard);
                                return { success: true, description: `æŠ½åˆ°äº† ${randomCard.name}` };
                            }
                            return { success: false, reason: 'ç‰Œåº«ä¸­æ²’æœ‰äººå±¬æ€§å¡' };
                        }
                    }
                };
            }

            static createCommunismCard() {
                const balance = CARD_BALANCE.COMMUNISM;
                return {
                    id: 'communism',
                    name: 'å…±ç”¢ä¸»ç¾©',
                    type: 'spell',
                    attribute: 'human',
                    rarity: 'rare',
                    stats: { hp_bonus: balance.hp },
                    description: 'è‹¥æˆ‘æ–¹è¡€é‡ä½æ–¼æ•µæ–¹ï¼Œå‰‡å›å¾©è¡€é‡è‡³èˆ‡æ•µæ–¹ç›¸åŒ',
                    effects: {
                        on_play: async function(gameState) {
                            const playerHP = gameState.player.current_hp;
                            const enemyHP = gameState.pitcher.current_hp;
                            
                            if (playerHP < enemyHP) {
                                const healAmount = Math.min(enemyHP - playerHP, gameState.player.max_hp - playerHP);
                                gameState.player.current_hp += healAmount;
                                return { success: true, description: `å›å¾©${healAmount}é»è¡€é‡ï¼Œè¿½å¹³æ•µæ–¹` };
                            }
                            return { success: false, reason: 'è¡€é‡ä¸ä½æ–¼æ•µæ–¹' };
                        }
                    }
                };
            }

            static createMulticultureCard() {
                const balance = CARD_BALANCE.MULTICULTURE;
                return {
                    id: 'multiculture',
                    name: 'å¤šå…ƒæ–‡åŒ–',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'rare',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'è¼”åŠ©ï¼šè‹¥å ´ä¸Šå­˜åœ¨â‰¥3ç¨®å±¬æ€§ï¼Œä½ æ‰‹ç‰Œä¸­æ‰€æœ‰çš„äººå±¬æ€§æ‰“è€…å¡æ”»æ“ŠåŠ›+10',
                    effects: {
                        on_support: async function(gameState) {
                            const attributes = new Set();
                            const fieldCards = [gameState.player.strike_zone, gameState.player.support_zone, gameState.player.spell_zone];
                            fieldCards.forEach(card => {
                                if (card) attributes.add(card.attribute);
                            });
                            
                            if (attributes.size >= 3) {
                                let boostedCount = 0;
                                gameState.player.hand.forEach(card => {
                                    if (card.attribute === 'human' && card.type === 'batter') {
                                        card.tempBonus = card.tempBonus || {};
                                        card.tempBonus.attack = (card.tempBonus.attack || 0) + 10;
                                        boostedCount++;
                                    }
                                });
                                return { success: true, description: `å ´ä¸Š${attributes.size}ç¨®å±¬æ€§ï¼Œ${boostedCount}å¼µäººå±¬æ‰“è€…+10æ”»æ“Š` };
                            }
                            return { success: false, reason: `å ´ä¸Šå±¬æ€§ç¨®é¡ä¸è¶³(${attributes.size}/3)` };
                        }
                    }
                };
            }

            static createProsperityCard() {
                const balance = CARD_BALANCE.PROSPERITY;
                return {
                    id: 'prosperity',
                    name: 'å…±æ¦®',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'rare',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'è¼”åŠ©ï¼šè‹¥å ´ä¸Šå­˜åœ¨â‰¥3ç¨®å±¬æ€§ï¼Œä½ çš„äººå±¬æ€§æ‰“è€…å¡+15æ”»æ“ŠåŠ›',
                    effects: {
                        on_support: async function(gameState) {
                            const attributes = new Set();
                            const fieldCards = [gameState.player.strike_zone, gameState.player.support_zone, gameState.player.spell_zone];
                            fieldCards.forEach(card => {
                                if (card) attributes.add(card.attribute);
                            });
                            
                            if (attributes.size >= 3) {
                                gameState.turnBuffs = gameState.turnBuffs || [];
                                gameState.turnBuffs.push({
                                    type: 'human_batter_attack_boost',
                                    value: 15,
                                    source: this.name
                                });
                                return { success: true, description: `å ´ä¸Š${attributes.size}ç¨®å±¬æ€§ï¼Œäººå±¬æ‰“è€…+15æ”»æ“ŠåŠ›` };
                            }
                            return { success: false, reason: `å ´ä¸Šå±¬æ€§ç¨®é¡ä¸è¶³(${attributes.size}/3)` };
                        }
                    }
                };
            }

            // å‚³èªªå¡ç‰Œ
            static createMasterCard() {
                const balance = CARD_BALANCE.MASTER;
                return {
                    id: 'master',
                    name: 'é›†å¤§æˆè€…',
                    type: 'batter',
                    attribute: 'human',
                    rarity: 'legendary',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'è¢«å‹•ï¼šæ­¤å¡åœ¨ä½ æ‰‹ä¸­æ™‚ï¼Œä½ æ¯æ‰“å‡ºä¸€å¼µäººå±¬æ€§å¡ï¼Œå…¶æ”»æ“ŠåŠ›+2ã€‚æ‰“æ“Šï¼šç‰Œçµ„ä¸­æ¯æœ‰ä¸€å¼µäººå±¬æ€§å¡ï¼Œæ”»æ“ŠåŠ›+1',
                    effects: {
                        passive_in_hand: async function(gameState, playedCard) {
                            if (playedCard.attribute === 'human') {
                                this.tempBonus = this.tempBonus || {};
                                this.tempBonus.attack = (this.tempBonus.attack || 0) + 2;
                                return { success: true, description: 'é›†å¤§æˆè€…æ”»æ“ŠåŠ›+2' };
                            }
                            return { success: false };
                        },
                        on_strike: async function(gameState) {
                            let humanCards = 0;
                            gameState.player.hand.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            gameState.player.discard_pile.forEach(card => {
                                if (card.attribute === 'human') humanCards++;
                            });
                            
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + humanCards;
                            
                            return { success: true, description: `äººå±¬æ€§å¡æ•¸é‡: ${humanCards}ï¼Œæ”»æ“ŠåŠ›+${humanCards}` };
                        }
                    }
                };
            }

            static createHeadPatCard() {
                const balance = CARD_BALANCE.HEAD_PAT;
                return {
                    id: 'head_pat',
                    name: 'æ‘¸é ­',
                    type: 'spell',
                    attribute: 'human',
                    rarity: 'legendary',
                    stats: { hp_bonus: balance.hp },
                    description: 'æŠ½3å¼µå¡ã€‚å…¶ä¸­æ¯æŠ½åˆ°ä¸€å¼µäººå±¬æ€§å¡ï¼Œè©²å¡+5æ”»æ“ŠåŠ›',
                    effects: {
                        on_play: async function(gameState) {
                            let drawnCards = [];
                            let humanCardsBoosted = 0;
                            
                            for (let i = 0; i < 3 && gameState.player.deck.length > 0; i++) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                                drawnCards.push(drawnCard.name);
                                
                                if (drawnCard.attribute === 'human') {
                                    drawnCard.permanentBonus = drawnCard.permanentBonus || {};
                                    drawnCard.permanentBonus.attack = (drawnCard.permanentBonus.attack || 0) + 5;
                                    humanCardsBoosted++;
                                }
                            }
                            
                            return { 
                                success: true, 
                                description: `æŠ½åˆ°${drawnCards.length}å¼µå¡ï¼Œ${humanCardsBoosted}å¼µäººå±¬å¡+5æ”»æ“ŠåŠ›` 
                            };
                        }
                    }
                };
            }

            // é™°å±¬å¡ç‰Œ
            static createShadowDevourCard() {
                const balance = CARD_BALANCE.SHADOW_DEVOUR;
                return {
                    id: 'shadow_devour',
                    name: 'æš—å½±åå™¬',
                    type: 'batter',
                    attribute: 'yin',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'æ‰“æ“Šï¼šè‹¥æœ¬å›åˆæ²’æœ‰æ‰“å‡ºå…¶ä»–é™°å±¬å¡ï¼Œæ­¤å¡ç²å¾—+10æ”»æ“ŠåŠ›ã€‚è¼”åŠ©ï¼šæŠ•æ‰‹æ”»æ“ŠåŠ›-3',
                    effects: {
                        on_strike: async function(gameState) {
                            const turnPlayedCards = gameState.turnPlayedCards || [];
                            const otherYinCards = turnPlayedCards.filter(card => 
                                card.attribute === 'yin' && card.id !== this.id
                            );
                            
                            if (otherYinCards.length === 0) {
                                this.tempBonus = this.tempBonus || {};
                                this.tempBonus.attack = (this.tempBonus.attack || 0) + 10;
                                return { success: true, description: 'æœ¬å›åˆæœªæ‰“å‡ºå…¶ä»–é™°å±¬å¡ï¼Œæ”»æ“ŠåŠ›+10' };
                            }
                            
                            return { success: false, reason: 'æœ¬å›åˆå·²æ‰“å‡ºå…¶ä»–é™°å±¬å¡' };
                        },
                        on_support: async function(gameState) {
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 3;
                            
                            return { success: true, description: 'æŠ•æ‰‹æ”»æ“ŠåŠ›-3' };
                        }
                    }
                };
            }
            
            static createLoneShadowCard() {
                const balance = CARD_BALANCE.LONE_SHADOW;
                return {
                    id: 'lone_shadow',
                    name: 'å­¤å½±',
                    type: 'spell',
                    attribute: 'yin',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp
                    },
                    description: 'æ¸›æŠ•æ‰‹5æ”»(æœ¬å›åˆ)ã€‚æŠ½1å¼µç‰Œ',
                    effects: {
                        on_play: async function(gameState) {
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 5;
                            
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                            }
                            
                            return {
                                success: true,
                                description: 'æŠ•æ‰‹æ”»æ“ŠåŠ›-5ï¼ŒæŠ½1å¼µç‰Œ'
                            };
                        }
                    }
                };
            }
            
            static createEvilGeniusCard() {
                const balance = CARD_BALANCE.EVIL_GENIUS;
                return {
                    id: 'evil_genius',
                    name: 'é‚ªæƒ¡å¤©æ‰',
                    type: 'batter',
                    attribute: 'yin',
                    rarity: 'rare',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'æ‰“æ“Šï¼šå¸å–æŠ•æ‰‹5é»æ”»æ“ŠåŠ›',
                    effects: {
                        on_strike: async function(gameState) {
                            gameState.pitcher.tempDebuff = gameState.pitcher.tempDebuff || {};
                            gameState.pitcher.tempDebuff.attack = 
                                (gameState.pitcher.tempDebuff.attack || 0) - 5;
                            
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + 5;
                            
                            return {
                                success: true,
                                description: 'å¸å–æŠ•æ‰‹5é»æ”»æ“ŠåŠ›'
                            };
                        }
                    }
                };
            }

            static createAmbushCard() {
                const balance = CARD_BALANCE.AMBUSH;
                return {
                    id: 'ambush',
                    name: 'å·è¥²',
                    type: 'batter',
                    attribute: 'yin',
                    rarity: 'rare',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'è¼”åŠ©ï¼šç›´æ¥é™ä½æŠ•æ‰‹10é»è¡€é‡',
                    effects: {
                        on_support: async function(gameState) {
                            gameState.pitcher.current_hp -= 10;
                            gameState.pitcher.current_hp = Math.max(0, gameState.pitcher.current_hp);
                            return { success: true, description: 'ç›´æ¥å°æŠ•æ‰‹é€ æˆ10é»å‚·å®³' };
                        }
                    }
                };
            }

            static createTimeStopCard() {
                const balance = CARD_BALANCE.TIME_STOP;
                return {
                    id: 'time_stop',
                    name: 'æ™‚é–“æš«åœ',
                    type: 'spell',
                    attribute: 'yin',
                    rarity: 'legendary',
                    stats: { hp_bonus: balance.hp },
                    description: 'æŠ•æ‰‹è·³éä»–çš„ä¸‹ä¸€å€‹å›åˆ',
                    effects: {
                        on_play: async function(gameState) {
                            gameState.pitcher.skipNextTurn = true;
                            return { success: true, description: 'æŠ•æ‰‹å°‡è·³éä¸‹ä¸€å›åˆ' };
                        }
                    }
                };
            }
            
            // é™½å±¬å¡ç‰Œ
            static createWeaponMasterCard() {
                const balance = CARD_BALANCE.WEAPON_MASTER;
                return {
                    id: 'weapon_master',
                    name: 'æ­¦å™¨å¤§å¸«',
                    type: 'batter',
                    attribute: 'yang',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'è¼”åŠ©ï¼šæ‰‹ç‰Œä¸­æ¯æœ‰ä¸€ç¨®ä¸åŒå±¬æ€§çš„å¡ï¼Œæ‰“è€…æ”»æ“ŠåŠ›+5',
                    effects: {
                        on_support: async function(gameState) {
                            const attributes = new Set();
                            gameState.player.hand.forEach(card => {
                                attributes.add(card.attribute);
                            });
                            
                            const boost = attributes.size * 5;
                            gameState.turnBuffs = gameState.turnBuffs || [];
                            gameState.turnBuffs.push({
                                type: 'batter_attack_boost',
                                value: boost,
                                source: this.name
                            });
                            
                            return {
                                success: true,
                                description: `æ‰‹ç‰Œ${attributes.size}ç¨®å±¬æ€§ï¼Œæ‰“è€…æ”»æ“ŠåŠ›+${boost}`
                            };
                        }
                    }
                };
            }
            
            static createYinYangHarmonyCard() {
                const balance = CARD_BALANCE.YIN_YANG_HARMONY;
                return {
                    id: 'yinyang_harmony',
                    name: 'é™°é™½èª¿å’Œ',
                    type: 'batter',
                    attribute: 'yang',
                    rarity: 'rare',
                    stats: {
                        hp_bonus: balance.hp,
                        attack: balance.attack,
                        crit: balance.crit
                    },
                    description: 'æ‰“æ“Šï¼šè‹¥è¼”åŠ©æ ¼ç‚ºé™°å±¬æ€§ï¼Œæ”»æ“ŠåŠ›ç¿»å€',
                    effects: {
                        on_strike: async function(gameState) {
                            const supportCard = gameState.player.support_zone;
                            
                            if (supportCard && supportCard.attribute === 'yin') {
                                const currentAttack = this.stats.attack + (this.tempBonus?.attack || 0);
                                this.tempBonus = this.tempBonus || {};
                                this.tempBonus.attack = currentAttack;
                                
                                return {
                                    success: true,
                                    description: 'è¼”åŠ©æ ¼ç‚ºé™°å±¬æ€§ï¼Œæ”»æ“ŠåŠ›ç¿»å€ï¼'
                                };
                            }
                            
                            return {
                                success: false,
                                reason: 'è¼”åŠ©æ ¼ä¸æ˜¯é™°å±¬æ€§'
                            };
                        }
                    }
                };
            }
            
            static createHolyLightCard() {
                const balance = CARD_BALANCE.HOLY_LIGHT;
                return {
                    id: 'holy_light',
                    name: 'è–å…‰',
                    type: 'spell',
                    attribute: 'yang',
                    rarity: 'common',
                    stats: {
                        hp_bonus: balance.hp
                    },
                    description: 'é¸æ“‡ä¸€å¼µæ‰‹ç‰Œï¼Œå…¶æ”»æ“ŠåŠ›+8(æœ¬å›åˆ)ã€‚æŠ½1å¼µç‰Œ',
                    effects: {
                        on_play: async function(gameState) {
                            const batterCard = gameState.player.hand.find(card => card.type === 'batter');
                            if (batterCard) {
                                batterCard.tempBonus = batterCard.tempBonus || {};
                                batterCard.tempBonus.attack = (batterCard.tempBonus.attack || 0) + 8;
                            }
                            
                            if (gameState.player.deck.length > 0) {
                                const drawnCard = gameState.player.deck.pop();
                                gameState.player.hand.push(drawnCard);
                            }
                            
                            return {
                                success: true,
                                description: batterCard ? `${batterCard.name}æ”»æ“ŠåŠ›+8ï¼ŒæŠ½1å¼µç‰Œ` : 'æŠ½1å¼µç‰Œ'
                            };
                        }
                    }
                };
            }

            static createLateGameCard() {
                const balance = CARD_BALANCE.LATE_GAME;
                return {
                    id: 'late_game',
                    name: 'å°ˆæ‰“å¾ŒæœŸ',
                    type: 'batter',
                    attribute: 'yang',
                    rarity: 'rare',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'æ‰“æ“Šï¼šæœ¬å ´ä½ æ¯æŠ½1å¼µç‰Œï¼Œæ­¤å¡æ”»æ“ŠåŠ›+3',
                    effects: {
                        on_strike: async function(gameState) {
                            const cardsDrawn = gameState.cardsDrawnThisGame || 0;
                            const bonus = cardsDrawn * 3;
                            this.tempBonus = this.tempBonus || {};
                            this.tempBonus.attack = (this.tempBonus.attack || 0) + bonus;
                            return { success: true, description: `å·²æŠ½${cardsDrawn}å¼µç‰Œï¼Œæ”»æ“ŠåŠ›+${bonus}` };
                        }
                    }
                };
            }

            static createResurrectionCard() {
                const balance = CARD_BALANCE.RESURRECTION;
                return {
                    id: 'resurrection',
                    name: 'æ­»è€…è˜‡ç”Ÿ',
                    type: 'deathrattle',
                    attribute: 'yang',
                    rarity: 'legendary',
                    stats: { hp_bonus: balance.hp, attack: balance.attack, crit: balance.crit },
                    description: 'æ­»è²ï¼šä½ æ£„ç‰Œå †ä¸­æ‰€æœ‰æ”»æ“ŠåŠ›â‰¥10çš„æ‰“è€…å¡æ´—å›ç‰Œåº«ã€‚è‹¥ç‰Œåº«â‰¥15å¼µï¼Œé™½å±¬å¡æ”»æ“ŠåŠ›+20ï¼›è‹¥<15å¼µï¼ŒæŠ½1å¼µé™½å±¬å¡',
                    effects: {
                        on_deathrattle: async function(gameState) {
                            const strongCards = gameState.player.discard_pile.filter(
                                card => card.type === 'batter' && (card.stats.attack + (card.tempBonus?.attack || 0)) >= 10
                            );
                            
                            if (strongCards.length > 0) {
                                strongCards.forEach(card => {
                                    const index = gameState.player.discard_pile.indexOf(card);
                                    gameState.player.discard_pile.splice(index, 1);
                                    gameState.player.deck.push(card);
                                });
                                
                                for (let i = gameState.player.deck.length - 1; i > 0; i--) {
                                    const j = Math.floor(Math.random() * (i + 1));
                                    [gameState.player.deck[i], gameState.player.deck[j]] = [gameState.player.deck[j], gameState.player.deck[i]];
                                }
                                
                                if (gameState.player.deck.length >= 15) {
                                    [...gameState.player.deck, ...gameState.player.hand].forEach(card => {
                                        if (card.attribute === 'yang') {
                                            card.permanentBonus = card.permanentBonus || {};
                                            card.permanentBonus.attack = (card.permanentBonus.attack || 0) + 20;
                                        }
                                    });
                                    return { success: true, description: `å¾©æ´»${strongCards.length}å¼µå¡ç‰Œï¼Œé™½å±¬å¡+20æ”»æ“Š` };
                                } else {
                                    const yangCards = gameState.player.deck.filter(card => card.attribute === 'yang');
                                    if (yangCards.length > 0) {
                                        const drawnCard = yangCards[Math.floor(Math.random() * yangCards.length)];
                                        const deckIndex = gameState.player.deck.indexOf(drawnCard);
                                        gameState.player.deck.splice(deckIndex, 1);
                                        gameState.player.hand.push(drawnCard);
                                    }
                                    return { success: true, description: `å¾©æ´»${strongCards.length}å¼µå¡ç‰Œï¼ŒæŠ½1å¼µé™½å±¬å¡` };
                                }
                            }
                            
                            return { success: false, reason: 'æ£„ç‰Œå †ä¸­æ²’æœ‰ç¬¦åˆæ¢ä»¶çš„å¡ç‰Œ' };
                        }
                    }
                };
            }
            
            static getStats() {
                const stats = {
                    total: this.cards.size,
                    byAttribute: {},
                    byType: {},
                    byRarity: {}
                };
                
                for (const [id, cardFactory] of this.cards.entries()) {
                    try {
                        const card = cardFactory();
                        stats.byAttribute[card.attribute] = (stats.byAttribute[card.attribute] || 0) + 1;
                        stats.byType[card.type] = (stats.byType[card.type] || 0) + 1;
                        stats.byRarity[card.rarity] = (stats.byRarity[card.rarity] || 0) + 1;
                    } catch (error) {
                        console.warn(`çµ±è¨ˆå¡ç‰Œ ${id} æ™‚å‡ºéŒ¯:`, error);
                    }
                }
                
                return stats;
            }
        }

        // ===== ğŸ® éŠæˆ²ç‹€æ…‹ç®¡ç† =====
        class GameState {
            constructor() {
                this.player = {
                    current_hp: GAME_BALANCE.PLAYER_INITIAL_HP,
                    max_hp: GAME_BALANCE.PLAYER_INITIAL_HP,
                    deck: [],
                    hand: [],
                    discard_pile: [],
                    strike_zone: null,
                    support_zone: null,
                    spell_zone: null,
                    active_buffs: []
                };
                
                this.pitcher = {
                    current_hp: GAME_BALANCE.PITCHER_INITIAL_HP,
                    max_hp: GAME_BALANCE.PITCHER_INITIAL_HP,
                    base_attack: 30,
                    current_attack: 30,
                    attribute: 'heaven',
                    active_debuffs: [],
                    stage: 1  // æ–°å¢ï¼šæŠ•æ‰‹éšæ®µ
                };
                
                this.gamePhase = 'DRAW_PHASE';
                this.turnCount = 1;
                this.turnBuffs = [];
                this.turnPlayedCards = [];
            }
        }

        // ===== âš”ï¸ æˆ°é¬¥ç³»çµ± =====
        class CombatSystem {
            constructor(eventBus) {
                this.eventBus = eventBus || new EventBus();
            }

            calculateDamage(gameState) {
                console.log('âš”ï¸ é–‹å§‹å‚·å®³è¨ˆç®—...');
                
                let totalAttack = 0;
                let totalCrit = 0;
                
                const strikeCard = gameState.player.strike_zone;
                const supportCard = gameState.player.support_zone;
                
                if (strikeCard) {
                    totalAttack += strikeCard.stats.attack;
                    totalCrit += strikeCard.stats.crit;
                    console.log(`ğŸ—¡ï¸ æ‰“æ“Šå€: ${strikeCard.name} - æ”»æ“Š:${strikeCard.stats.attack} æš´æ“Š:${strikeCard.stats.crit}`);
                }
                
                if (supportCard) {
                    totalAttack += supportCard.stats.attack;
                    totalCrit += supportCard.stats.crit;
                    console.log(`ğŸ›¡ï¸ è¼”åŠ©å€: ${supportCard.name} - æ”»æ“Š:${supportCard.stats.attack} æš´æ“Š:${supportCard.stats.crit}`);
                }

                const modifiedStats = this.applyEffectsAndBuffs(gameState, totalAttack, totalCrit, strikeCard, supportCard);
                totalAttack = modifiedStats.attack;
                totalCrit = modifiedStats.crit;
                
                console.log(`ğŸ’ª æ•ˆæœå¾Œæ•¸å€¼ - ç¸½æ”»æ“Š:${totalAttack} ç¸½æš´æ“Š:${totalCrit}`);

                let finalDamage = totalAttack * (1 + totalCrit / 100);
                console.log(`ğŸ§® æ ¸å¿ƒå…¬å¼: ${totalAttack} * (1 + ${totalCrit}/100) = ${finalDamage}`);

                const playerMainAttr = this.getPlayerMainAttribute(gameState);
                const pitcherAttr = gameState.pitcher.attribute;
                
                if (this.isStrongAgainst(playerMainAttr, pitcherAttr)) {
                    finalDamage *= 1.2;
                    console.log(`âš¡ å±¬æ€§å…‹åˆ¶: ${playerMainAttr} å…‹åˆ¶ ${pitcherAttr}, å‚·å®³ x1.2 = ${finalDamage}`);
                }

                finalDamage = Math.round(finalDamage);
                console.log(`ğŸ¯ æœ€çµ‚å‚·å®³: ${finalDamage}`);

                return {
                    finalDamage,
                    breakdown: {
                        baseAttack: totalAttack,
                        baseCrit: totalCrit,
                        critMultiplier: (1 + totalCrit / 100),
                        attributeBonus: this.isStrongAgainst(playerMainAttr, pitcherAttr) ? 1.2 : 1.0,
                        playerAttribute: playerMainAttr,
                        pitcherAttribute: pitcherAttr
                    }
                };
            }

            applyEffectsAndBuffs(gameState, baseAttack, baseCrit, strikeCard, supportCard) {
                let totalAttack = baseAttack;
                let totalCrit = baseCrit;

                if (strikeCard && strikeCard.tempBonus) {
                    if (strikeCard.tempBonus.attack) {
                        totalAttack += strikeCard.tempBonus.attack;
                        console.log(`âœ¨ ${strikeCard.name} è‡¨æ™‚æ”»æ“ŠåŠ›: +${strikeCard.tempBonus.attack}`);
                    }
                    if (strikeCard.tempBonus.crit) {
                        totalCrit += strikeCard.tempBonus.crit;
                        console.log(`âœ¨ ${strikeCard.name} è‡¨æ™‚æš´æ“Š: +${strikeCard.tempBonus.crit}`);
                    }
                }

                if (supportCard && supportCard.tempBonus) {
                    if (supportCard.tempBonus.attack) {
                        totalAttack += supportCard.tempBonus.attack;
                        console.log(`âœ¨ ${supportCard.name} è‡¨æ™‚æ”»æ“ŠåŠ›: +${supportCard.tempBonus.attack}`);
                    }
                    if (supportCard.tempBonus.crit) {
                        totalCrit += supportCard.tempBonus.crit;
                        console.log(`âœ¨ ${supportCard.name} è‡¨æ™‚æš´æ“Š: +${supportCard.tempBonus.crit}`);
                    }
                }

                gameState.player.active_buffs?.forEach(buff => {
                    if (buff.type === 'ATTACK_UP') {
                        totalAttack += buff.value;
                        console.log(`ğŸ”¥ å…¨å±€Buff: æ”»æ“ŠåŠ› +${buff.value}`);
                    }
                    if (buff.type === 'CRIT_UP') {
                        totalCrit += buff.value;
                        console.log(`âš¡ å…¨å±€Buff: æš´æ“Š +${buff.value}`);
                    }
                });

                gameState.turnBuffs?.forEach(buff => {
                    if (buff.type === 'human_batter_attack_boost' && strikeCard?.attribute === 'human') {
                        totalAttack += buff.value;
                        console.log(`ğŸ’ ${buff.source}: äººå±¬æ‰“è€…æ”»æ“ŠåŠ› +${buff.value}`);
                    }
                    if (buff.type === 'batter_attack_boost' && strikeCard?.type === 'batter') {
                        totalAttack += buff.value;
                        console.log(`âš”ï¸ ${buff.source}: æ‰“è€…æ”»æ“ŠåŠ› +${buff.value}`);
                    }
                });

                return { attack: totalAttack, crit: totalCrit };
            }

            isStrongAgainst(playerAttr, enemyAttr) {
                const advantages = {
                    'human': ['yin'],
                    'yin': ['yang'], 
                    'yang': ['heaven'],
                    'heaven': ['earth'],
                    'earth': ['human']
                };
                
                return advantages[playerAttr]?.includes(enemyAttr) || false;
            }

            getPlayerMainAttribute(gameState) {
                if (gameState.player.strike_zone) {
                    return gameState.player.strike_zone.attribute;
                }
                
                if (gameState.player.support_zone) {
                    return gameState.player.support_zone.attribute;
                }
                
                return 'human';
            }

            async executeCombat(gameState) {
                console.log('ğŸ® é–‹å§‹æˆ°é¬¥éšæ®µ...');
                
                if (!gameState.player.strike_zone) {
                    return { success: false, reason: 'æ‰“æ“Šå€æ²’æœ‰å¡ç‰Œ' };
                }

                const strikeCard = gameState.player.strike_zone;
                if (strikeCard.effects?.on_strike) {
                    console.log(`ğŸ¯ è§¸ç™¼ ${strikeCard.name} çš„æ‰“æ“Šæ•ˆæœ`);
                    const effectResult = await strikeCard.effects.on_strike.call(strikeCard, gameState);
                    if (effectResult.success) {
                        console.log(`âœ… æ‰“æ“Šæ•ˆæœ: ${effectResult.description}`);
                    }
                }

                const supportCard = gameState.player.support_zone;
                if (supportCard?.effects?.on_support) {
                    console.log(`ğŸ›¡ï¸ è§¸ç™¼ ${supportCard.name} çš„è¼”åŠ©æ•ˆæœ`);
                    const supportResult = await supportCard.effects.on_support.call(supportCard, gameState);
                    if (supportResult.success) {
                        console.log(`âœ… è¼”åŠ©æ•ˆæœ: ${supportResult.description}`);
                    }
                }

                const damageResult = this.calculateDamage(gameState);
                
                gameState.pitcher.current_hp -= damageResult.finalDamage;
                gameState.pitcher.current_hp = Math.max(0, gameState.pitcher.current_hp);
                
                // æª¢æŸ¥æ˜¯å¦éœ€è¦é€²å…¥ç¬¬äºŒéšæ®µ
                this.checkPitcherStageTransition(gameState);
                
                this.eventBus.emit('damage_dealt', {
                    damage: damageResult.finalDamage,
                    breakdown: damageResult.breakdown,
                    pitcherHP: gameState.pitcher.current_hp,
                    pitcherMaxHP: gameState.pitcher.max_hp
                });

                const pitcherDamage = this.calculatePitcherDamage(gameState);
                gameState.player.current_hp -= pitcherDamage;
                gameState.player.current_hp = Math.max(0, gameState.player.current_hp);

                console.log(`ğŸ¯ æˆ°é¬¥çµæœ: å°æŠ•æ‰‹é€ æˆ${damageResult.finalDamage}å‚·å®³, å—åˆ°${pitcherDamage}å‚·å®³`);

                return {
                    success: true,
                    playerDamageDealt: damageResult.finalDamage,
                    playerDamageReceived: pitcherDamage,
                    damageBreakdown: damageResult.breakdown
                };
            }

            // æ–°å¢ï¼šæª¢æŸ¥æŠ•æ‰‹éšæ®µè½‰æ›
            checkPitcherStageTransition(gameState) {
                if (gameState.pitcher.stage === 1 && gameState.pitcher.current_hp <= gameState.pitcher.max_hp * 0.5) {
                    console.log('ğŸ”¥ æŠ•æ‰‹é€²å…¥ç¬¬äºŒéšæ®µï¼');
                    gameState.pitcher.stage = 2;
                    gameState.pitcher.max_hp = GAME_BALANCE.PITCHER_STAGE2_HP;
                    gameState.pitcher.current_hp = Math.min(gameState.pitcher.current_hp + 50, gameState.pitcher.max_hp); // å›å¾©ä¸€äº›è¡€é‡
                    gameState.pitcher.current_attack = GAME_BALANCE.PITCHER_STAGE2_ATTACK;
                    gameState.pitcher.base_attack = GAME_BALANCE.PITCHER_STAGE2_ATTACK;
                    
                    this.eventBus.emit('pitcher_stage_transition', {
                        stage: 2,
                        newHP: gameState.pitcher.current_hp,
                        newMaxHP: gameState.pitcher.max_hp,
                        newAttack: gameState.pitcher.current_attack
                    });
                }
            }

            calculatePitcherDamage(gameState) {
                let pitcherDamage = gameState.pitcher.current_attack;
                
                if (gameState.pitcher.tempDebuff?.attack) {
                    pitcherDamage += gameState.pitcher.tempDebuff.attack;
                    console.log(`ğŸ”» æŠ•æ‰‹æ”»æ“ŠåŠ›æ¸›ç›Š: ${gameState.pitcher.tempDebuff.attack}`);
                }

                const playerAttr = this.getPlayerMainAttribute(gameState);
                const pitcherAttr = gameState.pitcher.attribute;
                
                if (this.isStrongAgainst(pitcherAttr, playerAttr)) {
                    pitcherDamage *= 0.8;
                    console.log(`ğŸ›¡ï¸ ç©å®¶è¢«å…‹åˆ¶ï¼Œå‚·å®³æ¸›å°‘20%: ${pitcherDamage}`);
                }

                return Math.round(pitcherDamage);
            }

            applyPitcherFatigue(gameState) {
                const fatigueRate = GAME_BALANCE.PITCHER_BASE_FATIGUE_RATE;
                
                gameState.pitcher.current_attack *= (1 - fatigueRate);
                gameState.pitcher.current_attack = Math.round(gameState.pitcher.current_attack);
                
                console.log(`ğŸ˜´ æŠ•æ‰‹ç–²å‹: æ”»æ“ŠåŠ›é™è‡³ ${gameState.pitcher.current_attack} (ç–²å‹ç‡: ${fatigueRate * 100}%)`);
                
                this.eventBus.emit('pitcher_fatigue', {
                    newAttack: gameState.pitcher.current_attack,
                    fatigueRate: fatigueRate
                });
            }
        }
        
        // ===== ğŸ¯ å›åˆç³»çµ± =====
        class TurnSystem {
            constructor(eventBus) {
                this.eventBus = eventBus || new EventBus();
            }

            async processTurn(gameState) {
                console.log(`ğŸ”„ é–‹å§‹ç¬¬ ${gameState.turnCount} å›åˆ...`);
                
                try {
                    await this.startOfTurn(gameState);
                    await this.drawPhase(gameState);
                    
                    gameState.gamePhase = 'PLAY_PHASE';
                    this.eventBus.emit('turn_phase_changed', { phase: 'PLAY_PHASE' });
                    
                } catch (error) {
                    console.error('âŒ å›åˆè™•ç†å¤±æ•—:', error);
                    this.eventBus.emit('turn_error', { error: error.message });
                }
            }

            async startOfTurn(gameState) {
                console.log('ğŸŒ… å›åˆé–‹å§‹éšæ®µ...');
                
                this.updateBuffDurations(gameState.player.active_buffs);
                this.updateBuffDurations(gameState.pitcher.active_debuffs);
                
                this.eventBus.emit('turn_start', { gameState });
            }

            async drawPhase(gameState) {
                console.log('ğŸ´ æŠ½ç‰Œéšæ®µ...');
                
                const handSizeLimit = GAME_BALANCE.HAND_SIZE_LIMIT;
                const drawCount = handSizeLimit - gameState.player.hand.length;
                
                console.log(`ğŸ“‹ ç•¶å‰æ‰‹ç‰Œ: ${gameState.player.hand.length}, éœ€æŠ½ç‰Œ: ${drawCount}`);
                
                for (let i = 0; i < drawCount; i++) {
                    if (!this.drawSingleCard(gameState)) {
                        console.log('âš ï¸ ç„¡æ³•ç¹¼çºŒæŠ½ç‰Œ');
                        break;
                    }
                }
                
                this.eventBus.emit('draw_phase_complete', { 
                    drawnCards: drawCount,
                    handSize: gameState.player.hand.length 
                });
            }

            drawSingleCard(gameState) {
                if (gameState.player.deck.length === 0) {
                    if (gameState.player.discard_pile.length === 0) {
                        console.log('ğŸ“š ç‰Œåº«å’Œæ£„ç‰Œå †éƒ½æ˜¯ç©ºçš„ï¼Œç„¡æ³•æŠ½ç‰Œ');
                        return false;
                    }
                    
                    console.log('ğŸ”€ ç‰Œåº«ç‚ºç©ºï¼Œé‡æ–°æ´—ç‰Œ...');
                    gameState.player.deck = [...gameState.player.discard_pile];
                    gameState.player.discard_pile = [];
                    this.shuffleDeck(gameState.player.deck);
                    
                    this.eventBus.emit('deck_shuffled', { deckSize: gameState.player.deck.length });
                }
                
                if (gameState.player.deck.length > 0) {
                    const card = gameState.player.deck.pop();
                    gameState.player.hand.push(card);
                    console.log(`ğŸ´ æŠ½åˆ°: ${card.name}`);
                    
                    this.eventBus.emit('card_drawn', { card });
                    return true;
                }
                
                return false;
            }

            async combatPhase(gameState, combatSystem) {
                console.log('âš”ï¸ æˆ°é¬¥éšæ®µ...');
                gameState.gamePhase = 'COMBAT_PHASE';
                
                const combatResult = await combatSystem.executeCombat(gameState);
                
                this.eventBus.emit('combat_complete', { result: combatResult });
                
                return combatResult;
            }

            async endOfTurn(gameState, combatSystem) {
                console.log('ğŸŒ™ å›åˆçµæŸéšæ®µ...');
                
                this.moveCardsToDiscard(gameState);
                
                combatSystem.applyPitcherFatigue(gameState);
                
                const gameOver = this.checkGameEnd(gameState);
                
                this.cleanupTurnBuffs(gameState);
                
                gameState.turnCount++;
                
                this.eventBus.emit('turn_end', { gameState, gameOver });
                
                return gameOver;
            }

            moveCardsToDiscard(gameState) {
                const zones = ['strike_zone', 'support_zone', 'spell_zone'];
                
                zones.forEach(zone => {
                    if (gameState.player[zone]) {
                        const card = gameState.player[zone];
                        gameState.player.discard_pile.push(card);
                        gameState.player[zone] = null;
                        console.log(`ğŸ—‚ï¸ ${card.name} ç§»å…¥æ£„ç‰Œå †`);
                    }
                });
            }

            updateBuffDurations(buffs) {
                if (!Array.isArray(buffs)) return;
                
                for (let i = buffs.length - 1; i >= 0; i--) {
                    const buff = buffs[i];
                    if (buff.duration > 0) {
                        buff.duration--;
                        if (buff.duration === 0) {
                            console.log(`â° BufféæœŸ: ${buff.type}`);
                            buffs.splice(i, 1);
                        }
                    }
                }
            }

            cleanupTurnBuffs(gameState) {
                gameState.turnBuffs = [];
                gameState.turnPlayedCards = [];
                
                [...gameState.player.hand, ...gameState.player.discard_pile].forEach(card => {
                    if (card.tempBonus) {
                        delete card.tempBonus;
                    }
                });
                
                if (gameState.pitcher.tempDebuff) {
                    delete gameState.pitcher.tempDebuff;
                }
            }

            checkGameEnd(gameState) {
                if (gameState.player.current_hp <= 0) {
                    return { gameOver: true, winner: 'pitcher', reason: 'ç©å®¶è¡€é‡æ­¸é›¶' };
                }
                
                if (gameState.pitcher.current_hp <= 0) {
                    return { gameOver: true, winner: 'player', reason: 'æŠ•æ‰‹è¡€é‡æ­¸é›¶' };
                }
                
                return { gameOver: false };
            }

            shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }
        }

        // ===== ğŸ¨ UI ç®¡ç†ç³»çµ± =====
        class UIManager {
            constructor() {
                this.elements = {};
                this.initializeElements();
                this.lastHandUpdate = 0; // æ–°å¢ï¼šé˜²æ­¢æ‰‹ç‰Œé »ç¹åˆ·æ–°
            }
            
            initializeElements() {
                this.elements = {
                    playerHp: document.getElementById('player-hp'),
                    playerHpBar: document.getElementById('player-hp-bar'),
                    pitcherHp: document.getElementById('pitcher-hp'),
                    pitcherHpBar: document.getElementById('pitcher-hp-bar'),
                    pitcherAttack: document.getElementById('pitcher-attack'),
                    pitcherAttribute: document.getElementById('pitcher-attribute'),
                    pitcherStage: document.getElementById('pitcher-stage'), // æ–°å¢
                    
                    turnCounter: document.getElementById('turn-counter'),
                    deckCount: document.getElementById('deck-count'),
                    discardCount: document.getElementById('discard-count'),
                    handCount: document.getElementById('hand-count'),
                    
                    strikeZone: document.getElementById('strike-zone'),
                    supportZone: document.getElementById('support-zone'),
                    spellZone: document.getElementById('spell-zone'),
                    handCards: document.getElementById('hand-cards'),
                    
                    gamePhase: document.getElementById('game-phase'),
                    phaseDescription: document.getElementById('phase-description'),
                    gameLog: document.getElementById('game-log'),
                    
                    attackBtn: document.getElementById('attack-btn'),
                    endTurnBtn: document.getElementById('end-turn-btn'),
                    resetBtn: document.getElementById('reset-btn')
                };
                
                return Object.values(this.elements).every(el => el !== null);
            }
            
            static generateCardClasses(attribute, rarity) {
                const baseClasses = 'w-28 h-36 rounded-xl p-3 text-xs cursor-pointer card-hover flex flex-col justify-between';
                
                const attributeColors = {
                    human: { base: 'human-base', dark: 'human-dark', text: 'human-text' },
                    yin: { base: 'yin-base', dark: 'yin-dark', text: 'yin-text' },
                    yang: { base: 'yang-base', dark: 'yang-dark', text: 'yang-text' },
                    heaven: { base: 'heaven-base', dark: 'heaven-dark', text: 'heaven-text' },
                    earth: { base: 'earth-base', dark: 'earth-dark', text: 'earth-text' }
                };
                
                const rarityStyles = {
                    common: (colors) => `bg-${colors.base}`,
                    rare: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-lg`,
                    legendary: (colors) => `bg-gradient-to-br from-${colors.base} to-${colors.dark} shadow-xl ring-2 ring-legendary-ring animate-glow`
                };
                
                const colors = attributeColors[attribute] || attributeColors.human;
                const backgroundStyle = rarityStyles[rarity](colors);
                
                return `${baseClasses} ${backgroundStyle} text-${colors.text}`;
            }

            static renderCard(cardData, index, showDetails = true) {
                const cardClasses = this.generateCardClasses(cardData.attribute, cardData.rarity);
                
                // æ–°å¢ï¼šæ ¹æ“šå¡ç‰Œé¡å‹æ·»åŠ ç‰¹æ•ˆé¡
                let specialClasses = '';
                if (cardData.type === 'spell') {
                    specialClasses += ' spell-card';
                } else if (cardData.type === 'deathrattle') {
                    specialClasses += ' deathrattle-card';
                }
                
                // å„ªåŒ–ï¼šæ¸›å°‘å‹•ç•«å»¶é²
                const animationDelay = index < 7 ? index * 0.05 : 0; // åªæœ‰å‰7å¼µå¡æœ‰å‹•ç•«å»¶é²
                
                return `
                    <div class="${cardClasses}${specialClasses} hand-card" draggable="true" data-card-index="${index}" style="animation-delay: ${animationDelay}s">
                        <div class="text-center mb-2">
                            <div class="font-bold text-sm mb-1">${cardData.name}</div>
                            <div class="text-[10px] opacity-80 bg-black/20 px-2 py-1 rounded">${cardData.attribute} â€¢ ${cardData.type}</div>
                        </div>
                        
                        ${showDetails ? `
                        <div class="flex-1 text-[10px] leading-tight opacity-90">
                            ${cardData.description}
                        </div>
                        ` : ''}
                        
                        <div class="flex justify-between text-[11px] font-bold mt-2 bg-black/20 p-1 rounded">
                            <span title="æ”»æ“ŠåŠ›">âš”ï¸${cardData.stats.attack || 0}</span>
                            <span title="æš´æ“Šå€¼">ğŸ’${cardData.stats.crit || 0}</span>
                        </div>
                    </div>
                `;
            }

            static showFloatingText(element, text, type = 'damage') {
                const floatingText = document.createElement('div');
                floatingText.className = `floating-text animate-${type}`;
                floatingText.textContent = text;
                
                const rect = element.getBoundingClientRect();
                floatingText.style.left = `${rect.left + rect.width / 2 - 20}px`;
                floatingText.style.top = `${rect.top}px`;
                
                document.body.appendChild(floatingText);
                
                setTimeout(() => {
                    if (document.body.contains(floatingText)) {
                        document.body.removeChild(floatingText);
                    }
                }, 1500);
            }

            addLogEntry(message, type = 'info') {
                const logContainer = this.elements.gameLog;
                const logEntry = document.createElement('div');
                
                const colors = {
                    info: 'text-gray-300',
                    success: 'text-green-400',
                    damage: 'text-red-400',
                    heal: 'text-green-400',
                    system: 'text-blue-400',
                    warning: 'text-yellow-400'
                };
                
                logEntry.className = colors[type] || colors.info;
                logEntry.innerHTML = `<span class="text-gray-500">[${new Date().toLocaleTimeString()}]</span> ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            updatePhaseDisplay(phase) {
                const phaseData = {
                    'DRAW_PHASE': { name: 'æŠ½ç‰Œéšæ®µ', description: 'è£œå……æ‰‹ç‰Œè‡³7å¼µ', color: 'bg-blue-600' },
                    'PLAY_PHASE': { name: 'å‡ºç‰Œéšæ®µ', description: 'æ‹–æ‹½å¡ç‰Œåˆ°æˆ°é¬¥å€åŸŸ', color: 'bg-green-600' },
                    'COMBAT_PHASE': { name: 'æˆ°é¬¥éšæ®µ', description: 'è¨ˆç®—å‚·å®³ä¸¦åŸ·è¡Œæ”»æ“Š', color: 'bg-red-600' }
                };
                
                const data = phaseData[phase];
                if (data) {
                    this.elements.gamePhase.textContent = data.name;
                    this.elements.gamePhase.className = `text-center py-3 px-4 rounded-lg font-bold text-white ${data.color}`;
                    this.elements.phaseDescription.textContent = data.description;
                }
            }

            updateUI(gameState) {
                this.updateHandDisplay(gameState);
                this.updateBattleZones(gameState);
                this.updateStatusDisplay(gameState);
                this.updateCounters(gameState);
                this.updatePhaseDisplay(gameState.gamePhase);
            }
            
            // å„ªåŒ–ï¼šé˜²æ­¢æ‰‹ç‰Œé »ç¹åˆ·æ–°
            updateHandDisplay(gameState) {
                if (!this.elements.handCards) return;
                
                const now = Date.now();
                if (now - this.lastHandUpdate < 100) { // 100mså…§ä¸é‡è¤‡æ›´æ–°
                    return;
                }
                this.lastHandUpdate = now;
                
                // ä½¿ç”¨ DocumentFragment å„ªåŒ– DOM æ“ä½œ
                const fragment = document.createDocumentFragment();
                const tempDiv = document.createElement('div');
                
                tempDiv.innerHTML = gameState.player.hand
                    .map((card, index) => UIManager.renderCard(card, index))
                    .join('');
                
                while (tempDiv.firstChild) {
                    fragment.appendChild(tempDiv.firstChild);
                }
                
                this.elements.handCards.innerHTML = '';
                this.elements.handCards.appendChild(fragment);
                
                if (this.elements.handCount) {
                    this.elements.handCount.textContent = gameState.player.hand.length;
                }
                
                // é‡æ–°ç¶å®šæ‹–æ‹½äº‹ä»¶
                this.bindCardDragEvents();
            }
            
            bindCardDragEvents() {
                const cards = document.querySelectorAll('[data-card-index]');
                cards.forEach(card => {
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', e.target.dataset.cardIndex);
                    });
                });
            }
            
            updateBattleZones(gameState) {
                const zones = [
                    { id: 'strike-zone', state: 'strike_zone', icon: 'ğŸ—¡ï¸', name: 'æ‰“æ“Š' },
                    { id: 'support-zone', state: 'support_zone', icon: 'ğŸ›¡ï¸', name: 'è¼”åŠ©' },
                    { id: 'spell-zone', state: 'spell_zone', icon: 'âœ¨', name: 'æ³•è¡“' }
                ];
                
                zones.forEach(({ id, state, icon, name }) => {
                    const zoneElement = document.getElementById(id);
                    if (!zoneElement) return;
                    
                    const card = gameState.player[state];
                    
                    if (card) {
                        zoneElement.innerHTML = UIManager.renderCard(card, -1, false);
                        zoneElement.classList.add('card-zone-occupied');
                    } else {
                        zoneElement.innerHTML = `
                            <div class="text-center text-gray-400">
                                <div class="text-3xl mb-2">${icon}</div>
                                <div class="text-sm">æ‹–æ‹½${name}å¡åˆ°æ­¤è™•</div>
                            </div>
                        `;
                        zoneElement.classList.remove('card-zone-occupied');
                    }
                });
            }
            
            updateStatusDisplay(gameState) {
                if (this.elements.playerHp) {
                    this.elements.playerHp.textContent = 
                        `${gameState.player.current_hp}/${gameState.player.max_hp}`;
                }
                if (this.elements.playerHpBar) {
                    this.elements.playerHpBar.style.width = 
                        `${(gameState.player.current_hp / gameState.player.max_hp) * 100}%`;
                }
                
                if (this.elements.pitcherHp) {
                    this.elements.pitcherHp.textContent = 
                        `${gameState.pitcher.current_hp}/${gameState.pitcher.max_hp}`;
                }
                if (this.elements.pitcherHpBar) {
                    this.elements.pitcherHpBar.style.width = 
                        `${(gameState.pitcher.current_hp / gameState.pitcher.max_hp) * 100}%`;
                }
                if (this.elements.pitcherAttack) {
                    this.elements.pitcherAttack.textContent = gameState.pitcher.current_attack;
                }
                if (this.elements.pitcherAttribute) {
                    this.elements.pitcherAttribute.textContent = gameState.pitcher.attribute;
                }
                
                // æ–°å¢ï¼šæ›´æ–°æŠ•æ‰‹éšæ®µé¡¯ç¤º
                if (this.elements.pitcherStage) {
                    const stage = gameState.pitcher.stage || 1;
                    this.elements.pitcherStage.textContent = `ç¬¬${stage}éšæ®µ`;
                    if (stage === 2) {
                        this.elements.pitcherStage.className = 'text-lg font-bold text-red-600 animate-pulse';
                    } else {
                        this.elements.pitcherStage.className = 'text-lg font-bold text-red-400';
                    }
                }
            }
            
            updateCounters(gameState) {
                if (this.elements.turnCounter) {
                    this.elements.turnCounter.textContent = gameState.turnCount;
                }
                if (this.elements.deckCount) {
                    this.elements.deckCount.textContent = gameState.player.deck.length;
                }
                if (this.elements.discardCount) {
                    this.elements.discardCount.textContent = gameState.player.discard_pile.length;
                }
            }
        }

        // ===== ğŸ® éŠæˆ²æ§åˆ¶å™¨ =====
        class GameController {
            constructor() {
                console.log('ğŸ® åˆå§‹åŒ–éŠæˆ²æ§åˆ¶å™¨...');
                
                this.eventBus = new EventBus();
                this.gameState = new GameState();
                this.combatSystem = new CombatSystem(this.eventBus);
                this.turnSystem = new TurnSystem(this.eventBus);
                this.uiManager = new UIManager();
                
                CardRegistry.initialize();
                this.setupEventListeners();
                this.isGameRunning = false;
                
                console.log('âœ… éŠæˆ²æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ');
            }

            setupEventListeners() {
                if (this.uiManager.elements.attackBtn) {
                    this.uiManager.elements.attackBtn.addEventListener('click', () => {
                        this.executeAttack();
                    });
                }
                
                if (this.uiManager.elements.endTurnBtn) {
                    this.uiManager.elements.endTurnBtn.addEventListener('click', () => {
                        this.endTurn();
                    });
                }
                
                if (this.uiManager.elements.resetBtn) {
                    this.uiManager.elements.resetBtn.addEventListener('click', () => {
                        if (confirm('ç¢ºå®šè¦é‡ç½®éŠæˆ²å—ï¼Ÿ')) {
                            this.resetGame();
                        }
                    });
                }
                
                this.setupDragAndDrop();
                
                this.eventBus.on('damage_dealt', (data) => {
                    this.uiManager.addLogEntry(`ğŸ’¥ é€ æˆå‚·å®³: ${data.damage}`, 'damage');
                    UIManager.showFloatingText(this.uiManager.elements.pitcherHpBar, `-${data.damage}`, 'damage');
                    this.uiManager.elements.pitcherHpBar.classList.add('animate-shake');
                    setTimeout(() => {
                        this.uiManager.elements.pitcherHpBar.classList.remove('animate-shake');
                    }, 500);
                });

                this.eventBus.on('turn_phase_changed', (data) => {
                    this.uiManager.updatePhaseDisplay(data.phase);
                });

                this.eventBus.on('card_drawn', (data) => {
                    this.uiManager.addLogEntry(`ğŸ´ æŠ½åˆ°: ${data.card.name}`, 'success');
                });

                // æ–°å¢ï¼šæŠ•æ‰‹éšæ®µè½‰æ›äº‹ä»¶
                this.eventBus.on('pitcher_stage_transition', (data) => {
                    this.uiManager.addLogEntry(`ğŸ”¥ æŠ•æ‰‹é€²å…¥ç¬¬${data.stage}éšæ®µï¼è¡€é‡å›å¾©ï¼Œæ”»æ“ŠåŠ›æå‡ï¼`, 'warning');
                    UIManager.showFloatingText(this.uiManager.elements.pitcherHpBar, 'ç¬¬äºŒéšæ®µï¼', 'heal');
                });
            }
            
            setupDragAndDrop() {
                const zones = ['strike-zone', 'support-zone', 'spell-zone'];
                
                zones.forEach(zoneId => {
                    const zone = document.getElementById(zoneId);
                    if (!zone) return;
                    
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        zone.classList.add('drag-over');
                    });

                    zone.addEventListener('dragleave', () => {
                        zone.classList.remove('drag-over');
                    });

                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.classList.remove('drag-over');
                        
                        const cardIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const targetZone = zone.dataset.zone || zoneId.replace('-', '_');
                        
                        this.playCard(cardIndex, targetZone);
                    });
                });
            }
            
            async playCard(cardIndex, targetZone) {
                const card = this.gameState.player.hand[cardIndex];
                if (!card) {
                    this.uiManager.addLogEntry('âŒ ç„¡æ•ˆçš„å¡ç‰Œç´¢å¼•', 'damage');
                    return;
                }

                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    this.uiManager.addLogEntry('âŒ ä¸åœ¨å‡ºç‰Œéšæ®µï¼', 'damage');
                    return;
                }

                if (this.gameState.player[targetZone]) {
                    this.uiManager.addLogEntry('âŒ è©²å€åŸŸå·²æœ‰å¡ç‰Œï¼', 'damage');
                    return;
                }

                const validPlacements = {
                    'strike_zone': ['batter'],
                    'support_zone': ['batter', 'support'],
                    'spell_zone': ['spell']
                };

                if (!validPlacements[targetZone].includes(card.type)) {
                    this.uiManager.addLogEntry('âŒ å¡ç‰Œé¡å‹ä¸åŒ¹é…ï¼', 'damage');
                    return;
                }

                this.gameState.player[targetZone] = card;
                this.gameState.player.hand.splice(cardIndex, 1);

                this.gameState.turnPlayedCards.push(card);

                if (card.effects?.on_play) {
                    const result = await card.effects.on_play.call(card, this.gameState);
                    if (result.success) {
                        this.uiManager.addLogEntry(`âœ¨ ${result.description}`, 'success');
                    }
                }

                const zoneNames = {
                    'strike_zone': 'æ‰“æ“Šå€',
                    'support_zone': 'è¼”åŠ©å€', 
                    'spell_zone': 'æ³•è¡“å€'
                };

                this.uiManager.addLogEntry(`ğŸ´ ${card.name} æ”¾ç½®åˆ°${zoneNames[targetZone]}`, 'success');
                this.uiManager.updateUI(this.gameState);
            }
            
            async executeAttack() {
                if (this.gameState.gamePhase !== 'PLAY_PHASE') {
                    this.uiManager.addLogEntry('âŒ ä¸åœ¨å‡ºç‰Œéšæ®µï¼', 'damage');
                    return;
                }
                
                if (!this.gameState.player.strike_zone) {
                    this.uiManager.addLogEntry('âŒ è«‹å…ˆæ”¾ç½®æ‰“æ“Šå¡ç‰Œï¼', 'damage');
                    return;
                }
                
                this.gameState.gamePhase = 'COMBAT_PHASE';
                this.uiManager.updatePhaseDisplay(this.gameState.gamePhase);
                
                this.uiManager.addLogEntry('âš”ï¸ æˆ°é¬¥é–‹å§‹ï¼', 'system');
                
                const combatResult = await this.turnSystem.combatPhase(this.gameState, this.combatSystem);
                
                if (this.gameState.pitcher.current_hp <= 0) {
                    this.uiManager.addLogEntry('ğŸ† å‹åˆ©ï¼æŠ•æ‰‹è¢«æ“Šæ•—äº†ï¼', 'success');
                    setTimeout(() => {
                        alert('ğŸ‰ æ­å–œå‹åˆ©ï¼\n\nåœ¨å®Œæ•´ç‰ˆæœ¬ä¸­ï¼Œé€™è£¡å°‡é€²å…¥çå‹µé¸æ“‡éšæ®µã€‚');
                    }, 1000);
                    this.uiManager.updateUI(this.gameState);
                    return;
                }
                
                setTimeout(() => {
                    this.pitcherAttack();
                }, 1000);
                
                this.uiManager.updateUI(this.gameState);
            }
            
            pitcherAttack() {
                const pitcherDamage = this.combatSystem.calculatePitcherDamage(this.gameState);
                
                this.gameState.player.current_hp -= pitcherDamage;
                this.gameState.player.current_hp = Math.max(0, this.gameState.player.current_hp);
                
                this.uiManager.addLogEntry(`ğŸ’¢ æŠ•æ‰‹åæ“Šï¼å—åˆ° ${pitcherDamage} é»å‚·å®³ï¼`, 'damage');
                UIManager.showFloatingText(this.uiManager.elements.playerHpBar, `-${pitcherDamage}`, 'damage');
                
                this.uiManager.elements.playerHpBar.classList.add('animate-shake');
                setTimeout(() => {
                    this.uiManager.elements.playerHpBar.classList.remove('animate-shake');
                }, 500);
                
                if (this.gameState.player.current_hp <= 0) {
                    this.uiManager.addLogEntry('ğŸ’€ å¤±æ•—ï¼ä½ è¢«æ“Šæ•—äº†ï¼', 'damage');
                    setTimeout(() => {
                        alert('ğŸ’€ éŠæˆ²çµæŸï¼\n\né»æ“Šé‡ç½®é–‹å§‹æ–°éŠæˆ²ã€‚');
                    }, 1000);
                    this.uiManager.updateUI(this.gameState);
                    return;
                }
                
                this.uiManager.updateUI(this.gameState);
                
                setTimeout(() => {
                    this.endTurn();
                }, 1500);
            }
            
            async endTurn() {
                const gameOver = await this.turnSystem.endOfTurn(this.gameState, this.combatSystem);
                
                if (gameOver.gameOver) {
                    this.uiManager.addLogEntry(`ğŸ† éŠæˆ²çµæŸ: ${gameOver.winner} ç²å‹ (${gameOver.reason})`, 'success');
                    return;
                }
                
                setTimeout(() => {
                    this.turnSystem.processTurn(this.gameState);
                    this.uiManager.updateUI(this.gameState);
                }, 1000);
            }
            
            resetGame() {
                this.gameState = new GameState();
                this.uiManager.elements.gameLog.innerHTML = '';
                this.startGame();
                this.uiManager.addLogEntry('ğŸ”„ éŠæˆ²å·²é‡ç½®', 'system');
            }
            
            async startGame() {
                console.log('ğŸš€ éŠæˆ²é–‹å§‹ï¼');
                
                this.initializeDeck();
                
                await this.turnSystem.processTurn(this.gameState);
                
                this.uiManager.addLogEntry('ğŸš€ éŠæˆ²é–‹å§‹ï¼æ­¡è¿ä¾†åˆ° MyGO!!!!! Roguelike TCG v2', 'success');
                this.uiManager.addLogEntry('ğŸ’¡ æç¤ºï¼šå°‡å¡ç‰Œæ‹–æ‹½åˆ°æˆ°é¬¥å€åŸŸï¼Œç„¶å¾Œé»æ“Šæ”»æ“Šï¼', 'system');
                this.uiManager.addLogEntry('âš¡ æ³•è¡“å¡å¸¶æœ‰âœ¨ç‰¹æ•ˆï¼Œæ­»è²å¡å¸¶æœ‰ğŸ’€æ¨™è¨˜', 'system');
                
                this.uiManager.updateUI(this.gameState);
            }
            
            initializeDeck() {
                const testDeckIds = [
                    'president', 'president', 'kindness', 'kindness', 
                    'hero', 'hero', 'lottery', 'strongman', 'democracy',
                    'shadow_devour', 'lone_shadow', 'evil_genius', 
                    'weapon_master', 'yinyang_harmony', 'holy_light'
                ];

                this.gameState.player.deck = testDeckIds.map(id => CardRegistry.create(id));
                this.turnSystem.shuffleDeck(this.gameState.player.deck);
                
                console.log(`ğŸ´ ç‰Œçµ„åˆå§‹åŒ–å®Œæˆ: ${this.gameState.player.deck.length} å¼µå¡ç‰Œ`);
            }
            
            getGameState() {
                return { ...this.gameState };
            }
        }

        // ===== ğŸš€ ä¸»æ‡‰ç”¨ç¨‹åº =====
        class MyGoTCGApplication {
            constructor() {
                console.log('ğŸ¸ MyGO!!!!! Roguelike TCG v2 å•Ÿå‹• - å„ªåŒ–ç‰ˆæœ¬');
                this.gameController = null;
                this.isInitialized = false;
            }
            
            async initialize() {
                if (this.isInitialized) return;
                
                try {
                    console.log('ğŸ”§ åˆå§‹åŒ–éŠæˆ²ç³»çµ±...');
                    
                    if (document.readyState === 'loading') {
                        await new Promise(resolve => {
                            document.addEventListener('DOMContentLoaded', resolve);
                        });
                    }
                    
                    this.gameController = new GameController();
                    
                    this.isInitialized = true;
                    console.log('âœ… æ‡‰ç”¨ç¨‹åºåˆå§‹åŒ–å®Œæˆ');
                    
                } catch (error) {
                    console.error('âŒ æ‡‰ç”¨ç¨‹åºåˆå§‹åŒ–å¤±æ•—:', error);
                    throw error;
                }
            }
            
            async startGame() {
                if (!this.isInitialized) {
                    console.error('âŒ æ‡‰ç”¨ç¨‹åºæœªåˆå§‹åŒ–');
                    return;
                }
                
                try {
                    console.log('ğŸš€ é–‹å§‹æ–°éŠæˆ²...');
                    this.gameController.startGame();
                } catch (error) {
                    console.error('âŒ é–‹å§‹éŠæˆ²æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
            
            runTests() {
                console.log('ğŸ§ª é‹è¡Œç³»çµ±æ¸¬è©¦...');
                
                try {
                    const testCards = ['president', 'kindness', 'shadow_devour', 'holy_light'];
                    testCards.forEach(cardId => {
                        try {
                            const card = CardRegistry.create(cardId);
                            console.log(`âœ… ${cardId}: ${card.name} (${card.type}, ${card.attribute})`);
                        } catch (error) {
                            console.error(`âŒ ${cardId} å‰µå»ºå¤±æ•—:`, error);
                        }
                    });
                    
                    console.log('âœ… ç³»çµ±æ¸¬è©¦å®Œæˆï¼');
                    
                } catch (error) {
                    console.error('âŒ æ¸¬è©¦å¤±æ•—:', error);
                }
            }
        }

        // ===== ğŸš€ æ‡‰ç”¨ç¨‹åºå•Ÿå‹• =====
        const app = new MyGoTCGApplication();

        app.initialize().then(() => {
            console.log('ğŸ‰ MyGO!!!!! TCG æ‡‰ç”¨ç¨‹åºå°±ç·’ - å„ªåŒ–ç‰ˆæœ¬');
            
            app.runTests();
            
            app.startGame();
            
        }).catch(error => {
            console.error('ğŸ’¥ æ‡‰ç”¨ç¨‹åºå•Ÿå‹•å¤±æ•—:', error);
        });

        window.MyGoTCG = app;
        
        window.gameDebug = {
            getState: () => app.gameController?.getGameState(),
            addCard: (cardId) => {
                if (app.gameController && CardRegistry.cards.has(cardId)) {
                    const card = CardRegistry.create(cardId);
                    app.gameController.gameState.player.hand.push(card);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`ğŸ”§ èª¿è©¦ï¼šæ·»åŠ äº† ${card.name}`);
                }
            },
            damageP: (amount) => {
                if (app.gameController) {
                    app.gameController.gameState.pitcher.current_hp -= amount;
                    app.gameController.gameState.pitcher.current_hp = Math.max(0, app.gameController.gameState.pitcher.current_hp);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`ğŸ”§ èª¿è©¦ï¼šå°æŠ•æ‰‹é€ æˆ ${amount} é»å‚·å®³`);
                }
            },
            heal: (amount) => {
                if (app.gameController) {
                    app.gameController.gameState.player.current_hp += amount;
                    app.gameController.gameState.player.current_hp = Math.min(app.gameController.gameState.player.max_hp, app.gameController.gameState.player.current_hp);
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log(`ğŸ”§ èª¿è©¦ï¼šå›å¾© ${amount} é»ç”Ÿå‘½å€¼`);
                }
            },
            stage2: () => {
                if (app.gameController) {
                    const pitcher = app.gameController.gameState.pitcher;
                    pitcher.stage = 2;
                    pitcher.max_hp = GAME_BALANCE.PITCHER_STAGE2_HP;
                    pitcher.current_attack = GAME_BALANCE.PITCHER_STAGE2_ATTACK;
                    app.gameController.uiManager.updateUI(app.gameController.gameState);
                    console.log('ğŸ”§ èª¿è©¦ï¼šæ‰‹å‹•è§¸ç™¼æŠ•æ‰‹ç¬¬äºŒéšæ®µ');
                }
            }
        };

    </script>
</body>
</html>